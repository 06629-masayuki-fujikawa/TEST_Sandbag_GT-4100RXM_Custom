/*
 * Copyright Notice:
 * Copyright Treck Incorporated  1997 - 2016
 * Copyright Zuken Elmic Japan   1997 - 2016
 * No portions or the complete contents of this file may be copied or
 * distributed in any form (including but not limited to printed or electronic
 * forms) without the expressed written consent of Treck Incorporated OR
 * Zuken Elmic.  Copyright laws and International Treaties protect the
 * contents of this file.  Unauthorized use is prohibited.
 * All rights reserved.
 *
 * Description: tfCheckOpenInterface
 *
 * Filename: trckopen.c
 * Author: Jason Schmidlapp
 * Date Created: 6/3/2002
 * $Source: source/sockapi/trckopen.c $
 *
 * Modification History
 * $Revision: 6.0.2.4 $
 * $Date: 2012/03/08 04:01:58JST $
 * $Author: pcarney $
 * $ProjectName: /home/mks/proj/tcpip.pj $
 * $ProjectRevision: 6.0.1.33 $
 */

/*
 * Include
 */
#include <trsocket.h>
#include <trmacro.h>
#include <trtype.h>
#include <trproto.h>
#include <trglobal.h>

/* constant declarations and enumerations */

/* type definitions */

/* local function prototypes */

/* local variable definitions */

/* static const tables */

/* macro definitions */

/****************************************************************************
* FUNCTION: tfCheckOpenInterface
*
* PURPOSE: Check the status of either IPv4 or IPv6 protocol operation on
*          the specified interface.
*
* PARAMETERS:
*   interfaceHandle:
*     Interface handle of the interface to check the status for.
*   protocolFamily:
*     The protocol family (i.e. IPv4 or IPv6) to check the status for. Specify
*     PF_INET for IPv4, PF_INET6 for IPv6.
*     
* RETURNS:
*   0:
*     Interface is open/up for the specified protocol family (i.e. IPv4 or IPv6).
*   TM_EINPROGRESS:
*     The interface is still being opened for the specified protocol family.
*   TM_ENETDOWN:
*     Interface is closed for the specified protocol family.
*   TM_EPERM:
*     Interface is disabled for the specified protocol family. When
*     protocolFamily is PF_INET6, this indicates that there is no link-local
*     scope IPv6 address configured on the interface, however the interface is
*     not closed, instead the IPv6 part of the interface is disabled and the
*     application cannot use IPv6 on this interface. This could occur if the
*     link-local IPv6 address generated by IPv6 stateless address
*     auto-configuration was determined to already be in use by a different
*     node (i.e. Duplicate Address Detection failed), in which case recovery
*     usually entails either setting a different interface ID, or manually
*     configuring a link-local IPv6 address on the interface, and then
*     attempting to restart the IPv6 part of the interface by calling
*     tfNgOpenInterface specifying an IPv6 address of all 0's (i.e. the IPv6
*     unspecified address).
*   TM_EINVAL:
*     Bad parameter value. Either you specified an invalid interface handle,
*     or the protocol family was not PF_INET or PF_INET6, or the protocol
*     family did not match the mode in which you are running the stack (for
*     example, if you run the stack in IPv4-only mode and specify a
*     protocolFamily of PF_INET6, you will get this error).

* NOTES:
*
****************************************************************************/
int tfCheckOpenInterface(ttUserInterface interfaceHandle,
                         int             protocolFamily)
{
    ttDeviceEntryPtr devEntryPtr;
    int              errorCode;
    tt16Bit          devFlag;

    devEntryPtr = (ttDeviceEntryPtr)interfaceHandle;
    
    errorCode = tfValidInterface(devEntryPtr);
    if( errorCode == TM_ENOERROR )
    {
        errorCode = TM_EINVAL;

        tm_call_lock_wait(&(devEntryPtr->devLockEntry));
        
#ifdef TM_USE_IPV4
        devFlag = devEntryPtr->devFlag;        
        if (protocolFamily == PF_INET)
        {
            if (devFlag & TM_DEV_CONNECTED)
            {
                errorCode = TM_ENOERROR;
            }
            else
            {
                if (devFlag & TM_DEV_CONNECTING)
                {
                    errorCode = TM_EINPROGRESS;
                }
                else
                {
                    errorCode = TM_ENETDOWN;
                }
            }
        }
#endif /* TM_USE_IPV4 */

#ifdef TM_USE_IPV6
        devFlag = devEntryPtr->dev6Flags;
        if (protocolFamily == PF_INET6)
        {
            if (devFlag & TM_6_LL_CONNECTED)
            {
                if (tm_6_dev_is_enabled(devEntryPtr))
                {
                    errorCode = TM_ENOERROR;
                }
                else
                {
/* Device is connected, but no link-local address is configured */
                    if (   (tm_6_link_local_cached(devEntryPtr))
                        || (devEntryPtr->dev6Flags
                                & TM_6_DEV_INIT_DELAY_STARTED)
                       )
                    {
/* configuration of link-local address is in progress */
                        errorCode = TM_EINPROGRESS;
                    }
                    else
                    {
                        errorCode = TM_EPERM;
                    }
                }
            }
            else
            {

                if (devFlag & TM_6_LL_CONNECTING)
                {
                    errorCode = TM_EINPROGRESS;
                }
                else
                {
                    errorCode = TM_ENETDOWN;
                }
            }
        }
#endif /* TM_USE_IPV6 */
        
        tm_call_unlock(&(devEntryPtr->devLockEntry));
    }
    
    return errorCode;
}



/***************** End Of File *****************/
