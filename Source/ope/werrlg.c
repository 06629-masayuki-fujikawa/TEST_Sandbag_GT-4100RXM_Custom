/*[]----------------------------------------------------------------------[]*/
/*| ｴﾗｰ登録                                                                |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author      : Hara                                                     |*/
/*| Date        : 2005-02-01                                               |*/
/*| UpDate      : 2005-06-01 T.Hashimoto adjusted                          |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
#include	<string.h>
#include	<stdio.h>
#include	"iodefine.h"
#include	"system.h"
#include	"tbl_rkn.h"
#include	"cnm_def.h"
#include	"mem_def.h"
#include	"Message.h"
#include	"pri_def.h"
#include	"rkn_def.h"
#include	"rkn_cal.h"
#include	"ope_def.h"
#include	"prm_tbl.h"
#include	"LKcom.h"
#include	"common.h"
#include	"ntnet.h"
#include	"ifm_ctrl.h"
#include	"mdl_def.h"
#include	"lkmain.h"
#include	"sysmnt_def.h"
#include	"flp_def.h"
#include	"mnt_def.h"
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加))
extern ushort	lcdbm_alarm_check(void);
extern void		lcdbm_notice_alm(ushort	warning);
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加))

typedef	union	{
	ushort USHORT;
	struct {
		ushort Level		:4;					/* 重要度レベル		（0〜8, 0=低）	*/
		ushort Mukou		:1;					/* 					（0=有効  ，1=無効）※ｱﾗｰﾑ時のみ				*/
		ushort BigHorn		:1;		/* B10  */	/* Bigホーン出力	（0=しない，1=する）※ｱﾗｰﾑ時のみ				*/
		ushort TroubleSigOut:2;		/* B9,8 */	/* トラブル信号出力	（0=しない，1=する，2=条件によりする，3=未使用）*/

		ushort NoticeToHost	:2;		/* B7,6 */	/* 通信でHostへ通知	（0=しない，1=する，2=条件によりする，3=未使用）*/
		ushort Close		:2;		/* B5,4 */	/* 休業				（0=しない，1=する，2=条件によりする，3=未使用）*/
		ushort Journal		:2;		/* B3,2 */	/* ジャーナル印字1	（0=しない，1=する，2=条件によりする，3=未使用）*/
		ushort LogRegist	:2;		/* B1,0 */	/* ログ登録			（0=しない，1=する，2=条件によりする，3=未使用)	*/
	} BIT;
} t_EAM_Act;	/* Error Monitor Alarm Action Infomation */
static char s_FullFactor[3];

// MH810105(S) MH364301 インボイス対応
//static short paperchk( void );
//static short paperchk2( void );
// MH810105(E) MH364301 インボイス対応

static const char moj_no[ 100 ] = {	// ﾓｼﾞｭｰﾙｺｰﾄﾞからERR_CHK[ｲﾝﾃﾞｯｸｽ]を参照するｲﾝﾃﾞｯｸｽを示す配列
mod_main, mod_read, mod_prnt, mod_coin, mod_note,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ0〜9
mod_ifrock, mod_ifflap,   (char)-1,     (char)-1,       (char)-1,       mod_crrflap,    mod_flapcrb,    (char)-1,       (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ10〜19
// MH810104 GG119201(S) 電子ジャーナル対応
//// MH810100(S) K.Onodera  2019/12/12 車番チケットレス(LCD_IF対応)
////      (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       mod_sodiac,     (char)-1,       (char)-1,       (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ20〜29
//        (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       mod_sodiac,  mod_tklslcd,       (char)-1,       mod_dc_net,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ20〜29
//// MH810100(E) K.Onodera  2019/12/12 車番チケットレス(LCD_IF対応)
// GG124100(S) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
//      (char)-1,       (char)-1,       mod_eja,       (char)-1,       (char)-1,       mod_sodiac,  mod_tklslcd,       (char)-1,       mod_dc_net,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ20〜29
        (char)-1,       (char)-1,       mod_eja,       (char)-1,       mod_cc,         mod_sodiac,  mod_tklslcd,       (char)-1,       mod_dc_net,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ20〜29
// GG124100(E) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
// MH810104 GG119201(E) 電子ジャーナル対応
// MH321800(S) D.Inaba ICクレジット対応 (決済リーダモジュールコード追加)
//      (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ30〜39
// MH810100(S) S.Fujii 2020/08/24 #4609 SDカードエラー対応
//      mod_barcode,      (char)-1,       (char)mod_ec,   (char)-1,       (char)-1,       (char)-1,       (char)-1,       mod_realtime,   (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ30〜39
      mod_barcode,      mod_sd,       (char)mod_ec,   (char)-1,       (char)-1,       (char)-1,       (char)-1,       mod_realtime,   (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ30〜39
// MH810100(E) S.Fujii 2020/08/24 #4609 SDカードエラー対応
// MH321800(E) D.Inaba ICクレジット対応 (決済リーダモジュールコード追加)
      mod_I2c,          (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ40〜49
// MH321800(S) Y.Tanizaki ICクレジット対応 不要機能削除(CCT)
//      (char)-1,       (char)-1,       (char)-1,       (char)-1,    mod_cct, mod_remote,     (char)-1,       (char)-1,       (char)-1, mod_mifr,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ50〜59
        (char)-1,       (char)-1,       (char)-1,       (char)-1,        (char)-1,      mod_remote,     (char)-1,       (char)-1,       (char)-1,        mod_mifr,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ50〜59
// MH321800(E) Y.Tanizaki ICクレジット対応 不要機能削除(CCT)
// MH321800(S) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
//      (char)-1,       (char)-1,  mod_Edy,mod_ntibk, mod_lprn, (char)-1,mod_ntnet, mod_ntdp,       (char)-1,mod_Suica,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ60〜69
        (char)-1,       (char)-1,       (char)-1,        mod_ntibk,      mod_lprn,      (char)-1,       mod_ntnet,      mod_ntdp,       (char)-1,        mod_Suica,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ60〜69
// MH321800(E) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
        mod_ntmf,       (char)-1,       mod_lanibk,     mod_dopaibk,     mod_cappi,      mod_idc,       mod_card,       mod_fomaibk,    (char)-1,       (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ70〜79
	    mod_SubCPU,     (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)mod_can,  (char)-1,       mod_Credit,     (char)-1,	// ﾓｼﾞｭｰﾙｺｰﾄﾞ80〜89
// GM849100(S) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
//        (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1	// ﾓｼﾞｭｰﾙｺｰﾄﾞ90〜99
        (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       mod_alarm,       (char)-1,       (char)-1,       (char)-1	// ﾓｼﾞｭｰﾙｺｰﾄﾞ90〜99
// GM849100(E) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
};

// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
static const char alm_moj[ 100 ] = {
// GG124100(S) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
// 	alm_mod_main,	alm_mod_sub1,	alm_mod_sub2,	(char)-1,       (char)-1,       alm_mod_auth,	(char)-1,       (char)-1,       (char)-1,       (char)-1,
	alm_mod_main,	alm_mod_sub1,	alm_mod_sub2,	(char)-1,       (char)-1,       alm_mod_auth,	(char)-1,       (char)-1,       alm_mod_cc,       (char)-1,
// GG124100(E) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
// GG124100(S) R.Endo 2022/08/29 車番チケットレス3.0 #6560 再起動発生（直前のエラー：メッセージキューフル E0011） [共通改善項目 No1528]
#ifdef DEBUG_ALARM_ACT
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       alm_mod_debug,
#else
// GG124100(E) R.Endo 2022/08/29 車番チケットレス3.0 #6560 再起動発生（直前のエラー：メッセージキューフル E0011） [共通改善項目 No1528]
	(char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,       (char)-1,
// GG124100(S) R.Endo 2022/08/29 車番チケットレス3.0 #6560 再起動発生（直前のエラー：メッセージキューフル E0011） [共通改善項目 No1528]
#endif
// GG124100(E) R.Endo 2022/08/29 車番チケットレス3.0 #6560 再起動発生（直前のエラー：メッセージキューフル E0011） [共通改善項目 No1528]
};
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))

const t_EAM_Act	ErrAct[ERR_MOD_MAX][ERR_NUM_MAX] = {						/* ｴﾗｰｺｰﾄﾞ表ﾓｼﾞｭｰﾙｺｰﾄﾞに対応	*/
//		0		1		2		3		4		5		6		7		8		9 
	{	// 0.Main		00
		0x0000, 0x3045, 0x5155, 0x5155, 0x0000, 0x3045, 0x3045, 0x3045, 0x4145, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4145, 0x4001, 0x0000, 0x2045, 0x2045, 0x2045, 0x4145, 0x4145, 0x4145, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x5141, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
// MH322914 (s) kasiyama 2016/07/13 ログ保存できない状態を改善[共通バグNo.1225](MH341106)
//		0x4005, 0x4005, 0x3045, 0x3045, 0x3045, 0x3045, 0x0000, 0x3045, 0x3045, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x4005, 0x4005, 0x3045, 0x3045, 0x3045, 0x3045, 0x0000, 0x3045, 0x3045, 0x3045, 	/* ｺｰﾄﾞ：50〜59 */
// MH322914 (e) kasiyama 2016/07/13 ログ保存できない状態を改善[共通バグNo.1225](MH341106)
		0x3045, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3045, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0045, 0x0000, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 0x3045, 0x3045, 0x5155, 0x5155, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 1.Reader		01
		0x0000, 0x4145, 0x5145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4145, 0x4145, 0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ：10〜19 */
		0x4145, 0x2005, 0x2005, 0x2005, 0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x2045, 0x2045, 0x4145, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 2.Printer	02
// MH810105(S) MH364301 インボイス対応
//		0x0000, 0x4145, 0x0000, 0x1045, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x4165, 0x0000, 0x1065, 0x4165, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
// MH810105(E) MH364301 インボイス対応
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
// MH810105(S) MH364301 インボイス対応
//		0x4145, 0x0000, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x4165, 0x0000, 0x1065, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
// MH810105(E) MH364301 インボイス対応
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 3.Coin		03
		0x0000, 0x5155, 0x0000, 0x0000, 0x0000, 0x4145, 0x4145, 0x4145, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x0000, 0x0000, 0x4145, 0x4145, 	/* ｺｰﾄﾞ：10〜19 */
		0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x2045, 0x2045, 0x0000, 0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 4.Note		04
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 5.Rock		05
		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4145, 0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ：20〜29 */
		0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2089, 0x2089, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 6.Mifare		 59
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 7.NT-NET 子機		66
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x2045, 	/* ｺｰﾄﾞ：10〜19 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x4065, 0x0000, 0x0000, 0x4065, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x2045, 0x0000, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 8.NT-NET 子機IBK		63
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ：10〜19 */
		0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// ﾗﾍﾞﾙﾌﾟﾘﾝﾀ	64
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4145, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x4145, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x1065, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// ﾌﾗｯﾌﾟ装置 10
		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2089, 0x2089, 	/* ｺｰﾄﾞ：30〜39 */
		0x4089, 0x2089, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x2089, 0x0000, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// MH321800(S) Y.Tanizaki ICクレジット対応 不要機能削除(CCT)
//	{	// CCT  Mod=54
//		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x1045, 0x1045, 0x1045, 	/* ｺｰﾄﾞ： 0〜 9 */
//		0x0000, 0x0000, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：10〜19 */
//		0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
//		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
//		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
//		0x1045, 0x1045, 0x1045, 0x4145, 0x4145, 0x1045, 0x0045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：60〜69 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
//		0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
//	},
// MH321800(E) Y.Tanizaki ICクレジット対応 不要機能削除(CCT)
	{	// LAN  Mod=72
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ：10〜19 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
// MH322917(S) A.Iiizumi 2018/09/21 長期駐車検出機能の拡張対応(ログ登録)
//		0x2045, 0x0000, 0x0000, 0x0000, 0x0045, 0x0045, 0x0045, 0x0000, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：50〜59 */
// MH322917(E) A.Iiizumi 2018/09/21 長期駐車検出機能の拡張対応(ログ登録)
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：60〜69 */
		0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
// 不具合修正(S) K.Onodera 2016/10/12 #1517 下り回線受信データ異常時に登録すべきエラーが登録されない(共通不具合No.1200)
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x2045, 0x2045, 0x2045, 0x0045, 0x0000,		/* ｺｰﾄﾞ：80〜89 */
// 不具合修正(E) K.Onodera 2016/10/12 #1517 下り回線受信データ異常時に登録すべきエラーが登録されない(共通不具合No.1200)
		0x0000, 0x2045, 0x2045, 0x2045, 0x0000, 0x2045, 0x0000, 0x0045, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// Dopa  Mod=73
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ：10〜19 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：60〜69 */
		0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0045, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// Suica 	69
		0x0000, 0x5145, 0x4145, 0x0000, 0x4045, 0x4045, 0x4045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x2045, 0x2045, 0x0000, 0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x5145, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},

// MH321800(S) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
//	{	// Edy 	62
//		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
//		0x4145, 0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
//		0x4145, 0x4145, 0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
//		0x3045, 0x3045, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
//		0x0045, 0x0045, 0x0045, 0x0045, 0x0041, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
//	},
// MH321800(E) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
	{	// Remote 55
		0x0000, 0x4245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x1045, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// FOMA  Mod=77
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ：10〜19 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0045, 0x0045, 0x0000, 0x0045, 0x0045, 0x2045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
// MH322917(S) A.Iiizumi 2018/09/21 長期駐車検出機能の拡張対応(ログ登録)
//		0x2045, 0x0000, 0x0000, 0x0000, 0x0045, 0x0045, 0x0045, 0x0000, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：50〜59 */
// MH322917(E) A.Iiizumi 2018/09/21 長期駐車検出機能の拡張対応(ログ登録)
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：60〜69 */
		0x0045, 0x0045, 0x0045, 0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：70〜79 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x2045, 0x2045, 0x2045, 0x0045, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0045, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},

	// 今後 新モジュールはここに定義を追加
	{	// NT-NET-DOPA MAF 	65→70
		/* 0       1       2       3       4       5       6       7       8       9 */
		0x0000, 0x4145, 0x2045, 0x2045, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ：10〜19 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：60〜69 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0045, 	/* ｺｰﾄﾞ：70〜79 */
		0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0045, 0x2045, 0x2045, 0x2045, 0x2045, 	/* ｺｰﾄﾞ：80〜89 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// NT-NET-DOPA  	67→65→70 
		/* 0       1       2       3       4       5       6       7       8       9 */
		0x0000, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// Cappi  Mod=74
		0x0000, 0x4145, 0x0000, 0x0000, 0x4145, 0x4145, 0x0000, 0x4045, 0x1045, 0x1045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x1045, 0x0000, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x1045, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x1045, 0x0000, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x1045, 0x1045, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// iD  Mod=75
		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4045, 0x4145, 0x1045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 	/* ｺｰﾄﾞ：60〜69 */
		0x1045, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// CRR Mod=15
		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4145, 0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2089, 0x2089, 	/* ｺｰﾄﾞ：30〜39 */
		0x4089, 0x2089, 0x0000, 0x0000, 0x0000, 0x4045, 0x4045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x2089, 0x0000, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{
		0x0000, 0x0000, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 簡易フラップ／ロック装置 Mod=16
		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ：10〜19 */
		0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 	/* ｺｰﾄﾞ：20〜29 */
		0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2089, 0x2089, 	/* ｺｰﾄﾞ：30〜39 */
		0x4089, 0x2089, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 	/* ｺｰﾄﾞ：60〜69 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// CAN通信	86
		0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x3045, 0x3045, 0x3045, 0x3045, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	//sodiac Mod=25
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4045, 0x4045, 0x4045, 0x4045, 0x4045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4045, 0x4045, 0x0000, 0x0000, 0x0000, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// I2C Mod=40
		//1		2		3		4		5		6		7		8		9		10
		0x0000, 0x0000, 0x0000, 0x4045, 0x4045, 0x4045, 0x4045, 0x4045, 0x0000, 0x4045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4045, 0x4045, 0x4045, 0x4045, 0x4045, 0x4045, 0x4045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// MH321800(S) D.Inaba ICクレジット対応 (決済リーダエラーレベル)
	{	// EC 	32
	//		0		1		2		3		4		5		6		7		8		9 
// MH810103 GG119202(S) 決済停止エラーの登録
//		0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x0000, 0x0000, 0x4045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x0000, 0x0000, 0x4045, 	/* ｺｰﾄﾞ： 0〜 9 */
// MH810103 GG119202(E) 決済停止エラーの登録
// MH810103 GG119202(S) 異常データフォーマット変更
//		0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
// MH810103 GG119202(S) 決済リーダからの再起動要求を記録する
//		0x2045, 0x4045, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
// MH810103 GG119202(S) E3210登録処理修正／E3211、E3212発生でトラブル信号出力する
//		0x2045, 0x4045, 0x3045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x4145, 0x4145, 0x4145, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
// MH810103 GG119202(E) E3210登録処理修正／E3211、E3212発生でトラブル信号出力する
// MH810103 GG119202(E) 決済リーダからの再起動要求を記録する
// MH810103 GG119202(E) 異常データフォーマット変更
		0x4045, 0x2045, 0x4045, 0x2045, 0x4045, 0x2045, 0x4045, 0x4045, 0x1045, 0x1045, 	/* ｺｰﾄﾞ：20〜29 */
// MH810103 GG119202(S) カード処理中タイムアウトでみなし決済扱いとする
//		0x1045, 0x1045, 0x0000, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
// MH810105(S) MH364301 みなし決済データ受信エラー追加
//		0x1045, 0x1045, 0x0000, 0x1045, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x1045, 0x1045, 0x0000, 0x1045, 0x3045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
// MH810105(E) MH364301 みなし決済データ受信エラー追加
// MH810103 GG119202(E) カード処理中タイムアウトでみなし決済扱いとする
// MH321800(S) フェーズエラー発生時に決済OK以外はリーダー切り離ししない
//		0x1045, 0x1045, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
// GG116202(S) JVMAリセットをエラー登録する
//		0x1045, 0x1045, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1045, 	/* ｺｰﾄﾞ：40〜49 */
// MH810103 GG119202(S) 電子マネー系詳細エラーコード追加
//		0x1045, 0x1045, 0x1045, 0x1045, 0x0000, 0x0000, 0x0000, 0x0000, 0x4045, 0x1045, 	/* ｺｰﾄﾞ：40〜49 */
// MH810103 GG119202(S) みなし決済扱い時の動作
//		0x1045, 0x1045, 0x1045, 0x1045, 0x5145, 0x1045, 0x0000, 0x0000, 0x4045, 0x1045, 	/* ｺｰﾄﾞ：40〜49 */
// MH810103 GG119202(S) 決済停止エラーの登録
//		0x1045, 0x1045, 0x1045, 0x1045, 0x5145, 0x1045, 0x0000, 0x5155, 0x4045, 0x1045, 	/* ｺｰﾄﾞ：40〜49 */
		0x1045, 0x1045, 0x1045, 0x1045, 0x3045, 0x1045, 0x4145, 0x5155, 0x4045, 0x1045, 	/* ｺｰﾄﾞ：40〜49 */
// MH810103 GG119202(E) 決済停止エラーの登録
// MH810103 GG119202(E) みなし決済扱い時の動作
// MH810103 GG119202(E) 電子マネー系詳細エラーコード追加
// GG116202(E) JVMAリセットをエラー登録する
// MH321800(E) フェーズエラー発生時に決済OK以外はリーダー切り離ししない
// MH321800(S) みなし決済発生時にエラー登録する
//		0x0000, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x4145, 	/* ｺｰﾄﾞ：50〜59 */
// MH810103 GG119202(S) 決済停止エラーの登録
//		0x4045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x4145, 	/* ｺｰﾄﾞ：50〜59 */
		0x4045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x1045, 0x3045, 	/* ｺｰﾄﾞ：50〜59 */
// MH810103 GG119202(E) 決済停止エラーの登録
// MH321800(E) みなし決済発生時にエラー登録する
// MH810103 GG119202(S) 使用マネー選択設定(50-0001,2)を参照しない
//		0x1045, 0x1045, 0x5145, 0x5145, 0x2045, 0x2045, 0x2045, 0x5155, 0x4045, 0x4045, 	/* ｺｰﾄﾞ：60〜69 */
// MH810103 GG119202(S) 決済停止エラーの登録
//		0x1045, 0x1045, 0x5145, 0x5145, 0x0000, 0x2045, 0x2045, 0x5155, 0x4045, 0x4045, 	/* ｺｰﾄﾞ：60〜69 */
		0x1045, 0x1045, 0x3045, 0x3045, 0x0000, 0x2045, 0x2045, 0x5155, 0x4045, 0x4045, 	/* ｺｰﾄﾞ：60〜69 */
// MH810103 GG119202(E) 決済停止エラーの登録
// MH810103 GG119202(E) 使用マネー選択設定(50-0001,2)を参照しない
// MH810103 GG119202(S) ブランド選択シーケンス変更（T／法人対応から移植）
//		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
// MH810105(S) MH364301 QRコード決済対応
//		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x2045, 	/* ｺｰﾄﾞ：70〜79 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 	/* ｺｰﾄﾞ：70〜79 */
// MH810105(E) MH364301 QRコード決済対応
// MH810103 GG119202(E) ブランド選択シーケンス変更（T／法人対応から移植）
// MH810105(S) MH364301 QRコード決済対応
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
// MH810105(E) MH364301 QRコード決済対応
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// MH321800(E) D.Inaba ICクレジット対応 (決済リーダエラーレベル)
// MH810100(S) K.Onodera  2019/12/12 車番チケットレス(LCD_IF対応)
	{	// 車番チケットレスLCD通信	26
	//		0		1		2		3		4		5		6		7		8		9 
		0x0000, 0x5155, 0x5155, 0x5155, 0x5155, 0x5155, 0x5155, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x5155, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// バーコード	30
	//		0		1		2		3		4		5		6		7		8		9 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4041, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4041, 0x0000, 0x0000, 0x0000, 0x0000, 0x2041, 0x2041, 0x2041, 0x2041, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// DC-NET通信	28
	//		0		1		2		3		4		5		6		7		8		9 
		0x0000, 0x4045, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
// MH810100(S) K.Onodera  2020/03/16 車番チケットレス(#4034 DC-NETで送信データ強制停止を受信してもデータを再送し続けてしまう)
//		0x2045, 0x2045, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
// MH810100(E) K.Onodera  2020/03/16 車番チケットレス(#4034 DC-NETで送信データ強制停止を受信してもデータを再送し続けてしまう)
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// リアルタイム通信	37
	//		0		1		2		3		4		5		6		7		8		9 
// GG129000(S) T.Nagai 2023/01/16 リアルタイム通信エラーテーブル修正
//		0x0000, 0x20A5, 0x0000, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x2025, 0x2025, 	/* ｺｰﾄﾞ： 0〜 9 */
//		0x4045, 0x0045, 0x0045, 0x0045, 0x2045, 0x0005, 0x0000, 0x0005, 0x0005, 0x0005, 	/* ｺｰﾄﾞ：10〜19 */
//		0x0005, 0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
//		0x0000, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x2045, 0x0005, 	/* ｺｰﾄﾞ：50〜59 */
//		0x0005, 0x0005, 0x0005, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
		0x0000, 0x4165, 0x0000, 0x0045, 0x0045, 0x0045, 0x0045, 0x4045, 0x4065, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0045, 0x0045, 0x2045, 0x0005, 0x0000, 0x0005, 0x0005, 0x0005, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0045, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
// GG129000(E) T.Nagai 2023/01/16 リアルタイム通信エラーテーブル修正
	},
// MH810100(E) K.Onodera  2019/12/12 車番チケットレス(LCD_IF対応)
// MH810100(S) S.Fujii 2020/08/24 #4609 SDカードエラー対応
	{	// SDカード	31
	//		0		1		2		3		4		5		6		7		8		9 
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
// GG129000(S) R.Endo 2023/06/21 車番チケットレス4.1 #7063 運用中にSDカードのファイルシステムが破損する(FCR P230154)
// 		0x0000, 0x4045, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x4045, 0x4045, 0x0000, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
// GG129000(E) R.Endo 2023/06/21 車番チケットレス4.1 #7063 運用中にSDカードのファイルシステムが破損する(FCR P230154)
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// MH810100(E) S.Fujii 2020/08/24 #4609 SDカードエラー対応
// MH810104 GG119201(S) 電子ジャーナル対応
	{	// 電子ジャーナル	22
// MH810104 GG119201(S) 電子ジャーナル対応（トラブル信号が出力されない）
//		0x0000, 0x4145, 0x1045, 0x4145, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
// MH810105(S) MH364301 インボイス対応
//		0x0000, 0x4145, 0x1045, 0x4145, 0x4145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x4165, 0x1065, 0x4165, 0x4165, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
// MH810105(E) MH364301 インボイス対応
// MH810104 GG119201(E) 電子ジャーナル対応（トラブル信号が出力されない）
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x2045, 0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// MH810104 GG119201(E) 電子ジャーナル対応
// GG124100(S) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
	{	// クラウド版料金計算エンジン	24
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x3045, 0x3045, 0x3045, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x3045, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// GG124100(E) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
// GM849100(S) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
	{	// 名鉄協商　アラーム　96
		0x0000, 0x5041, 0x5041, 0x5041, 0x0000, 0x4041, 0x4041, 0x0000, 0x0000, 0x4041, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 	/* ｺｰﾄﾞ：10〜19 */
		0x4041, 0x4041, 0x4041, 0x4041, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3041, 0x0000, 0x0000, 0x0000, 0x5041, 	/* ｺｰﾄﾞ：90〜99 */
	},
// GM849100(E) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信

//↑新規項目はここから上に追加(CRM/CRW共通)
	{	// サブCPU機能	80
		0x0000, 0x4145, 0x3045, 0x0000, 0x4145, 0x4145, 0x4145, 0x4145, 0x4145, 0x0045, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x1045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},

//↑新規項目はここから上に追加(CRM/CRW共通)
	{	// クレジット関連	88
		0x0000, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0045, 0x0045, 0x0000, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0045, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x2045, 0x2045, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x2045, 0x2045, 0x2045, 0x2045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0045, 0x0045, 0x0045, 0x2045, 0x2045, 0x2045, 0x0045, 0x0045, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x2045, 0x0000, 0x0000, 0x2045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},

//↑新規項目はここから上に追加(CRW固有)
	// 以下 3桁のエラーコード 特殊処理用
	{	// LAN2
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：100〜109 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：110〜119 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：120〜129 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：130〜139 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：140〜149 */
		0x0000, 0x0045, 0x0045, 0x0000, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：150〜159 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：160〜169 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：170〜179 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：180〜189 */
		0x0000, 0x0000, 0x2045, 0x2045, 0x0000, 0x2045, 0x0000, 0x0045, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：190〜199 */
	},
	{	// Dopa2
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：100〜109 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：110〜119 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：120〜129 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：130〜139 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：140〜149 */
		0x0000, 0x0045, 0x0045, 0x0000, 0x0045, 0x0045, 0x0045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：150〜159 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：160〜169 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：170〜179 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：180〜189 */
		0x0000, 0x0000, 0x2045, 0x2045, 0x0000, 0x2045, 0x0000, 0x0045, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：190〜199 */
	},
};	/* ※休業要因の設定内容ﾁｪｯｸは opncls() で行う。条件変更時は opncls() も変更すること */

const uchar	ErrAct_index[ERR_MOD_MAX] = {						/* ｴﾗｰｺｰﾄﾞ表ﾓｼﾞｭｰﾙｺｰﾄﾞに対応	*/
	ERRMDL_MAIN,
	ERRMDL_READER,
	ERRMDL_PRINTER,
	ERRMDL_COIM,
	ERRMDL_NOTE,
	ERRMDL_IFROCK,
	ERRMDL_MIFARE,
	ERRMDL_NTNET,
	ERRMDL_NTNETIBK,
	ERRMDL_LABEL,
	ERRMDL_IFFLAP,
// MH321800(S) Y.Tanizaki ICクレジット対応 不要機能削除(CCT)
//	ERRMDL_CCT,
// MH321800(E) Y.Tanizaki ICクレジット対応 不要機能削除(CCT)
	ERRMDL_LANIBK,
	ERRMDL_DOPAIBK,
	ERRMDL_SUICA,
// MH321800(S) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
//	ERRMDL_EDY,
// MH321800(E) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
	ERRMDL_REMOTE,
	ERRMDL_FOMAIBK,
	ERRMDL_NTNETDOPAMAF,
	ERRMDL_NTNETDOPA,
	ERRMDL_CAPPI,
	ERRMDL_IDC,
	ERRMDL_CRRFLAP,
	ERRMDL_CARD,
	ERRMDL_FLAP_CRB,
	ERRMDL_CAN,
	ERRMDL_SODIAC,
	ERRMDL_I2C,
// MH321800(S) G.So ICクレジット対応
	ERRMDL_EC,
// MH321800(E) G.So ICクレジット対応
// MH810100(S) K.Onodera  2019/12/12 車番チケットレス(LCD_IF対応)
	ERRMDL_TKLSLCD,
	ERRMDL_BARCODE,
// MH810100(E) K.Onodera  2019/12/12 車番チケットレス(LCD_IF対応)
// MH810103(s) 電子マネー対応 再送時のエラー種別がおかしい不具合修正
	ERRMDL_DC_NET,	// DC-NET通信
	ERRMDL_REALTIME,// リアルタイム通信
	ERRMDL_SD,		// SDカード
// MH810103(e) 電子マネー対応 再送時のエラー種別がおかしい不具合修正
// MH810104 GG119201(S) 電子ジャーナル対応
	ERRMDL_EJA,
// MH810104 GG119201(E) 電子ジャーナル対応
// GM849100(S) 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
	ERRMDL_ALARM,
// GM849100(E) 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
	ERRMDL_SUBCPU,
	ERRMDL_CREDIT,

	ERRMDL_LANIBK,
	ERRMDL_DOPAIBK,
};

// GM849100(S) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
const uchar	Alarm_Err96[ERR_NUM_MAX][2] = {					// [0]:アラームモジュールＮｏ
															// [1]:アラームコードＮｏ
									0,		0xFF,
									0,		1,		// 1
									0,		5, 		
									0,		6, 		
									0,		10, 	
									1,		1,		
									1,		2,		
									1,		3,		
									1,		4,		
									1,		6,		
									1,		7,		// 10
									1,		15,		
									1,		16,		
									1,		17,		
									1,		18,		
									1,		21,		
									1,		22,		
									1,		23,		
									1,		24,		
									1,		26,		
									1,		28,		// 20
									1,		29,		
									1,		31,		
									1,		32,		
									1,		35,		
									1,		36,		
									1,		37,		
									1,		43,		
									1,		44,		
									1,		46,		
									1,		47,		// 30
									1,		48,		
									1,		49,		
									1,		53,		
									1,		54,		
									1,		61,		
									1,		62,		
									1,		63,		
									1,		65,		
									1,		66,		
									1,		67,		// 40
									1,		68,		
									1,		69,		
									1,		72,		
									1,		73,		
									1,		76,		
									1,		77,		
									1,		80,		
									1,		81,		
									2,		1,		
									2,		2,		// 50
									2,		3,		
									2,		4,		
									2,		5,		
									2,		6,		
									2,		7,		
									2,		8,		
									2,		9,		
									2,		10,		
									2,		16,		
									2,		17,		// 60
									2,		18,		
									2,		19,		
									2,		20,		
									2,		21,		
									2,		22,		
									2,		23,		
									2,		24,		
									2,		30,		
									2,		31,		
									2,		32,		// 70
									2,		33,		
									2,		40,		
									2,		41,		
									2,		42,		
									2,		43,		
									2,		44,		
									2,		45,		
									2,		46,		
									2,		47,		
									2,		48,		// 80
									2,		49,		
									2,		50,		
									2,		51,		
									2,		52,		
									2,		53,		
									2,		54,		
									2,		90,		
									2,		91,		
									2,		92,		
									2,		93,		// 90
									2,		97,		
									2,		98,		
									3,		1,		
									3,		2,		
									1,		84,		
									0,		0xFF,	
									0,		0xFF,	
									0,		20, 	// 0020 ⇒ 9698
									0xFF,	0xFF,	
								};
// GM849100(E) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信

/*[]----------------------------------------------------------------------[]*/
/*| Error Check & Loging                                                   |*/
/*| 付属情報なし時のｴﾗｰ登録処理                                            |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_chk( md, no, knd, data )                            |*/
/*| PARAMETER    : md      : Error Module Code (00-99)                     |*/
/*|              : no      : Error No. (1-99)                              |*/
/*|              : knd     : 0=解除 1=発生 2=発生解除                      |*/
/*|              : data    : 0=ｴﾗｰ情報無し 1=ｴﾗｰ情報有り(ascii) 2:(bin)    |*/
/*|              : err_ctl : 0:発生中ﾁｪｯｸする 1:しない                     |*/
/*|                          0=状態変化なし時は登録動作をしない            |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(GT4700より流用)                                    |*/
/*| Date         : 2006-02-16                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2006 AMANO Corp.---[]*/
void	err_chk( char md, char no, char knd, char data, char err_ctl )
{
	err_chk2( md, no, knd, 0, err_ctl, (void*)0L );
}

/*[]----------------------------------------------------------------------[]*/
/*| Error Check & Loging                                                   |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_chk2( md, no, knd, f_data, err_ctl, pData )         |*/
/*| PARAMETER    : md      : Error Module Code (00-99)                     |*/
/*|              : no      : Error No. (1-99)                              |*/
/*|              : knd     : 0=解除 1=発生 2=発生解除                      |*/
/*|              : f_data  : 0=ｴﾗｰ情報無し 1=ｴﾗｰ情報有り(ascii) 2:(bin)    |*/
/*|              : err_ctl : 0:発生中ﾁｪｯｸする 1:しない                     |*/
/*|                          0=状態変化なし時は登録動作をしない            |*/
/*|              : pData   : 登録する付属ﾃﾞｰﾀへのﾎﾟｲﾝﾀ                     |*/
/*|                          f_data≠0時のみ有効                           |*/
/*|                          f_data=1(ascii)時は、uchar[160]へのﾎﾟｲﾝﾀ      |*/
/*|                          f_data=2(bin)時は、ulongへのﾎﾟｲﾝﾀ             |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(GT4700より流用)                                    |*/
/*| Date         : 2006-02-16                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2006 AMANO Corp.---[]*/
void	err_chk2( char md, char no, char knd, char f_data, char err_ctl, void *pData )
{
	int		i, j;
	int		onf, trb, cls;
	T_FrmErrJou		ErrJouPreqData;										// ｴﾗｰ情報印字要求用ﾊﾞｯﾌｧ
	char	moj;
	uchar	f_LogRegist=0;												// 1=LOG登録済み
	char	wk_Err_onf;
	uchar	level;														// エラーログのレベル
	uchar	uno = (uchar)no;
	uchar	minus = 0;
	uchar	f_return = 0;												// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
// MH322914(S) K.Onodera 2016/09/07 AI-V対応：エラーアラーム
	int		 pos = -1;
// MH322914(E) K.Onodera 2016/09/07 AI-V対応：エラーアラーム

	/* 登録ｂﾌ有効性チェック */
	moj = moj_no[md];
	if( moj == (char)-1 ){													// 各ﾓｼﾞｭｰﾙｂﾌ格納場所
		return;
	}
	if (moj >= ERR_MOD_ALL) {
		return;
	}
	if ((md == 72) || (md == 73)) {
		if (uno >= 100) {
			uno -= 100;
			minus = 1;
			moj = (char)(ERR_MOD_ALL + (md - 72));
		}
	}
	if (uno >= ERR_NUM_MAX) {
		return;
	}
// MH810102(S) 電子マネー対応 #5329 精算機の電源をOFF/ONした時、E2615-265が発生する
	if( md == ERRMDL_TKLSLCD && WAKEUP_OVER == 0){
		// LCDの起動をまつ
		if(knd == 1){
			// 発生の場合は、解除を入れておく(解除だけが登録されないように)
			ERR_CHK[moj][uno] = 0;
		}
		return;
	}
// MH810102(E) 電子マネー対応 #5329 精算機の電源をOFF/ONした時、E2615-265が発生する

	/* 登録処理を行う内容か確認（二重登録のガード）*/
	if( (ERR_CHK[moj][uno] == knd) && (err_ctl == 0) ){					// ｴﾗｰ内容に変化がなく、
																		// 変化無し時は登録処理を行はない指示の場合
		return;															// 処理終了
	}																	// ERR_CHK[] には 1=発生中，0=未発生の値が入る

	/* 本機で有効なｴﾗ-かﾁｪｯｸ */
	if( !ErrAct[moj][uno].USHORT ){										// 未定義ｴﾗｰ
		return;
	}

	/** 有効エラーと判定 **/

	/* LOG登録準備ｴﾘｱにﾃﾞｰﾀｾｯﾄ */
	memcpy( &Err_work.Date_Time, &CLK_REC, sizeof( date_time_rec ) );	// 発生日時
	Err_work.Errsyu = md;												// ｴﾗｰ種別
	if (minus) {
		Err_work.Errcod = (uchar)(uno+100);								// ｴﾗｰｺｰﾄﾞ
	} else {
		Err_work.Errcod = uno;											// ｴﾗｰｺｰﾄﾞ
	}
	Err_work.Errdtc = knd;												// ｴﾗｰ発生/解除
	Err_work.Errlev = ErrAct[moj][uno].BIT.Level;						// ｴﾗｰﾚﾍﾞﾙ
	Err_work.ErrDoor = 0;
	if( OPE_Is_DOOR_ERRARM && OPECTL.f_DoorSts ){
		Err_work.ErrDoor = ERR_LOG_DOOR_STS_F;							// ドア開状態とする
		if( avm_alarm_flg != 0 ){
			// 警報発砲中
			Err_work.ErrDoor = 0;										// ドア閉状態とする
		}
	}
	Err_work.Errinf = (uchar)f_data;									// ｴﾗｰ情報有無
	if( 1 == f_data )													// 付属ﾃﾞｰﾀ(ascii)あり
		memcpy( &Err_work.Errdat, pData, ERR_LOG_ASC_DAT_SIZE );	// ascii ｴﾗｰ情報をｾｯﾄ
	else if( 2 == f_data )												// 付属ﾃﾞｰﾀ(bin)あり
	{
		memcpy(&Err_work.ErrBinDat,pData,sizeof( Err_work.ErrBinDat ));		// bin ｴﾗｰ情報をｾｯﾄ
// MH321800(S) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
//		if( md == ERRMDL_EDY ){
//			if( no == 43 )
//				Err_work.ErrBinDat = (*(uchar*)pData);
//		}
// MH321800(E) Y.Tanizaki ICクレジット対応 不要機能削除(Edy)
	}
	if( moj == mod_flapcrb &&											// ロック装置エラー
		( uno == ERR_FLAPLOCK_LOCKCLOSEFAIL || uno == ERR_FLAPLOCK_LOCKOPENFAIL ||	// 開/閉 or 上昇/下降エラー
		  uno == ERR_FLAPLOCK_DOWNRETRYOVER || uno == ERR_FLAPLOCK_DOWNRETRY ) ) {	// 保護処理リトライオーバー/保護処理開始
		if( 0 == LKcom_RoomNoToType(Err_work.ErrBinDat) ) {							// エラーの車室はロック装置
			if(prm_get( COM_PRM, S_PRN, 19, 1, 1 ) == 1 ){							// 18-0019E=1　上昇/下降及び開/閉ロック印字する
				Err_work.Errinf = 2;												// 付属ﾃﾞｰﾀ(bin)あり
			}
		}
		else { 																		// エラーの車種はフラップ
			if(prm_get( COM_PRM, S_PRN, 19, 1, 3 ) == 1 ){							// 18-0019C=1　上昇/下降及び開/閉ロック印字する
				Err_work.Errinf = 2;												// 付属ﾃﾞｰﾀ(bin)あり
			}
		}
// MH322914(S) K.Onodera 2016/09/07 AI-V対応：エラーアラーム
	  	if( Err_work.Errinf == 2 ){
			pos = LKcom_RoomNoToIndex( Err_work.ErrBinDat );
// MH322914(S) K.Onodera 2016/12/22 [静的解析-570]配列インデックスオーバー
//		  	if( pos >= 0 ){
			if( pos >= 0 && pos < LOCK_MAX ){
// MH322914(E) K.Onodera 2016/12/22 [静的解析-570]配列インデックスオーバー
				ERR_LOCK_INFO[pos][uno-ERR_FLAPLOCK_LOCKCLOSEFAIL]	= Err_work.ErrBinDat;
		  	}
	  	}
// MH322914(E) K.Onodera 2016/09/07 AI-V対応：エラーアラーム
	}
	/* Err_work ｴﾘｱは使用後もｸﾘｱしない（問題ないため） */

	/* LOG登録 */
	switch( ErrAct[moj][uno].BIT.LogRegist ){
	case	1:															// LOG登録必要
		f_LogRegist = 1;
		Log_regist( LOG_ERROR );										// ｴﾗｰﾛｸﾞ登録
		break;
	default:
		break;
	}

	/** 運転継続不可能な致命的エラーの場合、LOG登録のみを行い装置Resetする **/
	if( (md == ERRMDL_MAIN) && (uno == ERR_MAIN_MESSAGEFULL) && (knd == 1) ){	// ﾒｰﾙｷｭｰFullｴﾗｰ
		System_reset();													// Main CPU reset (It will not retrun from this function)
	}

	/* Hostへ通知が必要（通信電文送信）*/
	switch( ErrAct[moj][uno].BIT.NoticeToHost ){
	case	2:															// 条件付LOG登録必要（現在なし）
		if( moj == mod_flapcrb ) {
			// ﾌﾗｯﾌﾟ装置上昇下降ﾛｯｸで印字しない設定時は通信も印字も発生中表示も行わない(ﾛｸﾞ登録のみ)
			if( uno == ERR_FLAPLOCK_LOCKCLOSEFAIL || uno == ERR_FLAPLOCK_LOCKOPENFAIL) {
				if( 0 == LKcom_RoomNoToType(Err_work.ErrBinDat) ) {			// エラーの車室はロック装置
					if(prm_get( COM_PRM, S_PRN, 19, 1, 1 ) == 0 ){
						f_return = 1;										// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
						break;
					}
				}
				else {														// フラップ
					if(prm_get( COM_PRM, S_PRN, 19, 1, 3 ) == 0 ){
						f_return = 1;										// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
						break;
					}
				}
			}
			else if( uno == ERR_FLAPLOCK_DOWNRETRYOVER || uno == ERR_FLAPLOCK_DOWNRETRY ) {
				// このエラーはフラップのみ
				if(prm_get( COM_PRM, S_PRN, 19, 1, 3 ) == 0 ){
					f_return = 1;											// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
					break;
				}
			}
		}
	default:
		break;
	}

	/* ジャーナル印字 */
	switch( ErrAct[moj][uno].BIT.Journal ){
	case	2:															// 条件付ｼﾞｬｰﾅﾙ出力（現在なし）
		if( moj == mod_flapcrb ) {
			// ﾌﾗｯﾌﾟ装置上昇下降ﾛｯｸで印字しない設定時は通信も印字も発生中表示も行わない(ﾛｸﾞ登録のみ)
			if( uno == ERR_FLAPLOCK_LOCKCLOSEFAIL || uno == ERR_FLAPLOCK_LOCKOPENFAIL) {
				if( 0 == LKcom_RoomNoToType(Err_work.ErrBinDat) ) {			// エラーの車室はロック装置
					if(prm_get( COM_PRM, S_PRN, 19, 1, 1 ) == 0 ){
						f_return = 1;										// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
						break;
					}
				}
				else {														// フラップ
					if(prm_get( COM_PRM, S_PRN, 19, 1, 3 ) == 0 ){
						f_return = 1;										// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
						break;
					}
				}
			}
			else if( uno == ERR_FLAPLOCK_DOWNRETRYOVER || uno == ERR_FLAPLOCK_DOWNRETRY ) {
				// このエラーはフラップのみ
				if(prm_get( COM_PRM, S_PRN, 19, 1, 3 ) == 0 ){
					f_return = 1;											// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
					break;
				}
			}
		}
	case	1:															// ｼﾞｬｰﾅﾙ出力必要
		if( f_LogRegist ){												// LOG登録しないとｼﾞｬｰﾅﾙ印字できない
			if( PrnJnlCheck() == ON ){									//	ｼﾞｬｰﾅﾙﾌﾟﾘﾝﾀ接続ありの場合
				// NOTE:ERR_LOG_DATは印字バッファとして使用する
				memcpy( &ERR_LOG_DAT.Err_log_dat[ERR_LOG_DAT.Err_wtp], &Err_work, sizeof( Err_log ) );
				level = ERR_LOG_DAT.Err_log_dat[ERR_LOG_DAT.Err_wtp].Errlev;	// エラーレベルセット
				if (level >= (uchar)prm_get(COM_PRM, S_PRN, 18, 1, 3)) {
					ErrJouPreqData.prn_kind = J_PRI;											// 出力ﾌﾟﾘﾝﾀ（ｼﾞｬｰﾅﾙ）
					ErrJouPreqData.prn_data = &ERR_LOG_DAT.Err_log_dat[ ERR_LOG_DAT.Err_wtp ];		// ﾃﾞｰﾀﾎﾟｲﾝﾀｾｯﾄ
					queset( PRNTCBNO, PREQ_ERR_JOU, sizeof(T_FrmErrJou), &ErrJouPreqData );		// 印字要求ﾒｯｾｰｼﾞ登録
				}
				ERR_LOG_DAT.Err_wtp++;	/* ﾗｲﾄﾎﾟｲﾝﾀ +1 */
				if( ERR_LOG_DAT.Err_wtp >= ERR_LOG_CNT ){
					ERR_LOG_DAT.Err_wtp = 0;
				}
			}
		}
		break;
	default:
		break;
	}

	IFM_Snd_Error();

	if( f_return ){														// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
		return;
	}

	/* 発生/復旧時の処理 */
	if( 2 == knd )														// 発生&復旧ｴﾗｰの場合はここまで
		return;

	wk_Err_onf = Err_onf;

	/* 発生時の処理 */
	if( 1 == knd ){														// ｴﾗｰ発生
		/* ｴﾗｰ発生状況登録 */
		ERR_CHK[moj][uno] = knd;											// ｴﾗｰ状況登録
// MH322914(S) K.Onodera 2016/09/07 AI-V対応：エラーアラーム
		if( 2 == f_data ){	// binデータあり？
			ERR_INFO[moj][uno] = Err_work.ErrBinDat;
		}
// MH322914(E) K.Onodera 2016/09/07 AI-V対応：エラーアラーム

		Err_onf = 1;													// 現在発生中ｴﾗｰ有り情報ｾｯﾄ

		/* トラブル信号出力 */
		switch( ErrAct[moj][uno].BIT.TroubleSigOut ){
		case	2:														// 条件付出力
			if ((md == ERRMDL_REMOTE) && (no == 1)) {
// MH322914(S) K.Onodera 2016/10/12 AI-V対応
//				if (prm_get(COM_PRM, S_PAY, 25, 1, 3) != 1) {
				if( !_is_Normal_pip() ){
// MH322914(E) K.Onodera 2016/10/12 AI-V対応
					break;	// ParkiPRO接続無し
				}
				if (prm_get(COM_PRM, S_CEN, 12, 1, 1) == 1) {
					break;	// トラブル信号出力しない
				}
			} else {
				break;	// 現在トラブル信号出力は遠隔(55)のHost側通信エラー(1)のみ
			}
		case	1:														// 出力必要
			if(((md == ERRMDL_LANIBK) && (no == 1)) ||
				((md == ERRMDL_FOMAIBK) && (no == 1))){
				if(prm_get(COM_PRM, S_NTN, 121, 1, 1)) {
					break;	// 駐車場センター形式時のE7201,E7701はトラブル信号出力しない
				}
			}
			Err_trb = 1;												// ﾄﾗﾌﾞﾙ有り(ﾄﾗﾌﾞﾙ信号出力指示)
			break;
		default:
			break;
		}

		/* 休業ﾁｪｯｸ (条件付の項目はopncls()でﾁｪｯｸする) */
		if( 1 == ErrAct[moj][uno].BIT.Close ){							// 休業指定
			Err_cls = 1;												// 休業要因あり
		}
	}
	/* ｴﾗｰ復旧時の処理 */
	else if( 0 == knd ){												// ｴﾗｰ復旧

		if( moj == mod_flapcrb )
		{
			
			if( uno == ERR_FLAPLOCK_LOCKCLOSEFAIL )
			{
				if( LKopeLockErrCheck( 0, _MTYPE_LOCK ) != 0 )
				{	// 閉ロックあり
					return;
				}
				if( LKopeLockErrCheck( 0, _MTYPE_INT_FLAP ) != 0 )
				{	// 下降ロックあり
					return;
				}
			}
			else if( uno == ERR_FLAPLOCK_LOCKOPENFAIL )
			{
				if( LKopeLockErrCheck( 1, _MTYPE_LOCK ) != 0 )
				{	// 閉ロックあり
					return;
				}
				if( LKopeLockErrCheck( 1, _MTYPE_INT_FLAP ) != 0 )
				{	// 上昇ロックあり
					return;
				}
			}
			// ﾌﾗｯﾌﾟ装置異常の解除は「全フラップで解除であった場合に解除とする」
			// が通常動作だが、E1140，E1141は発生復旧情報をERR_CHK[]に反映しないので
			// この処理を割愛する（表示もトラブル信号出力も無いので問題なし）
		}

		/* ｴﾗｰ発生状況登録 */
		ERR_CHK[moj][uno] = knd;											// ｴﾗｰ状況登録
// MH322914(S) K.Onodera 2016/09/07 AI-V対応：エラーアラーム
		ERR_INFO[moj][uno] = 0;
// MH322914(E) K.Onodera 2016/09/07 AI-V対応：エラーアラーム

		/* 残りｴﾗｰ発生状況ﾁｪｯｸ */
		onf = trb = cls = 0;
		for( i = 0; i < ERR_MOD_MAX; i++ ){
			for( j = 1; j < ERR_NUM_MAX; j++ ){
				if( ERR_CHK[i][j] != 0 ){								// 現在発生中のｴﾗｰあり
					onf = 1;											// まだ発生中ｴﾗｰあり

					if( 1 == ErrAct[i][j].BIT.TroubleSigOut ){			// 発生中のｴﾗｰはﾄﾗﾌﾞﾙ信号出力要因
						trb = 1;										// ﾄﾗﾌﾞﾙ信号出力要因まだあり
					}
					else if( 2 == ErrAct[i][j].BIT.TroubleSigOut ){		// 発生中のｴﾗｰは条件付でﾄﾗﾌﾞﾙ信号出力要因
						/* 条件ﾁｪｯｸ */
						if ((ErrAct_index[i] == ERRMDL_REMOTE) && (j == 1)) {	// E5501
// MH322914(S) K.Onodera 2016/10/12 AI-V対応
//							if( (prm_get(COM_PRM, S_PAY, 25, 1, 3) == 1) &&		// ParkiPRO接続あり かつ
							if( _is_Normal_pip() &&								// ParkiPRO接続あり かつ
// MH322914(E) K.Onodera 2016/10/12 AI-V対応
								(prm_get(COM_PRM, S_CEN, 12, 1, 1) == 0) ) 		// トラブル信号出力する
							{
								/* 信号出力条件を満たしていたら以下実施 */
								trb = 1;										// ﾄﾗﾌﾞﾙ信号出力要因まだあり
							}
						}
					}
					/* 休業ﾁｪｯｸ (条件付の項目はopncls()でﾁｪｯｸする) */
					if( 1 == ErrAct[i][j].BIT.Close ){					// 休業指定
						cls = 1;										// 休業要因まだあり
					}
				}
			}
		}
		if( onf == 0 ){													// 現在発生中のｴﾗｰが無くなった
			Err_onf = 0;												// 現在発生中ｴﾗｰなし
		}
		if( trb == 0 ){													// 現在発生中のﾄﾗﾌﾞﾙ信号出力要因ｴﾗｰが無くなった
			Err_trb = 0;												// ﾄﾗﾌﾞﾙなし
		}
		if( cls == 0 ){													// 現在発生中の休業要因ｴﾗｰが無くなった
			Err_cls = 0;												// 休業要因ｴﾗｰなし（条件付以外のもの）
		}
	}

	/* ｴﾗｰ有無状況 変化あり */
	if( wk_Err_onf != Err_onf )											// 発生状況変化あり
		queset( OPETCBNO, MID_STSCHG_ANY_ERROR, 0, NULL );				// OpeMainへ通知

	/* 休業ﾁｪｯｸ */
	switch( ErrAct[moj][uno].BIT.Close ){
	case	2:															// 条件付出力
	case	1:															// 出力必要
		/* 休業要因ｴﾗｰに変化あり */
		queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );					// OpeMainへ通知
		/* 発生要因に対する休業ﾁｪｯｸはOpe主ﾓｼﾞｭｰﾙにて行う opncls() */
		break;
	}
}

// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加))
//[]----------------------------------------------------------------------[]
///	@brief			 Error Check & Loging 
//[]----------------------------------------------------------------------[]
///	@param		: md		: Error Module Code (00-99)
///				: no		: Error No. (1-99)
///				: knd		: 0=解除 1=発生 2=発生解除
///				: f_data	: 0=ｴﾗｰ情報無し 1=ｴﾗｰ情報有り(ascii) 2:(bin)
///				: err_ctl	: 0:発生中ﾁｪｯｸする 1:しない
///				              0=状態変化なし時は登録動作をしない
///				: pData		: 登録する付属ﾃﾞｰﾀへのﾎﾟｲﾝﾀ
///							  f_data≠0時のみ有効
///							  f_data=1(ascii)時は、uchar[160]へのﾎﾟｲﾝﾀ
///							  f_data=2(bin)時は、ulongへのﾎﾟｲﾝﾀ
///				: date		: 発生解除日時
///	@return			None
//[]----------------------------------------------------------------------[]
///	@date			Create	: 2019/11/15<br>
///					Update	: 
//[]------------------------------------- Copyright(C) 2019 AMANO Corp.---[]
// MH810100(S) S.Nishimoto 2020/04/08 静的解析(20200407:222)対応
//void err_chk3( char md, char no, char knd, char f_data, char err_ctl, void *pData, date_time_rec* date )
void err_chk3( char md, char no, char knd, char f_data, char err_ctl, void *pData, unsigned int length, date_time_rec* date )
// MH810100(E) S.Nishimoto 2020/04/08 静的解析(20200407:222)対応
{
	int		i, j;
	int		onf, trb, cls;
	T_FrmErrJou		ErrJouPreqData;										// ｴﾗｰ情報印字要求用ﾊﾞｯﾌｧ
	char	moj;
	uchar	f_LogRegist=0;												// 1=LOG登録済み
	char	wk_Err_onf;
	uchar	level;														// エラーログのレベル
	uchar	uno = (uchar)no;
	uchar	minus = 0;
	uchar	f_return = 0;												// 1=Host送信かジャーナル印字が条件付の場合途中で終了する

	// 登録ｂﾌ有効性チェック
	moj = moj_no[md];
	if( moj == (char)-1 ){													// 各ﾓｼﾞｭｰﾙｂﾌ格納場所
		return;
	}
	if (moj >= ERR_MOD_ALL) {
		return;
	}
	if ((md == 72) || (md == 73)) {
		if (uno >= 100) {
			uno -= 100;
			minus = 1;
			moj = (char)(ERR_MOD_ALL + (md - 72));
		}
	}
	if (uno >= ERR_NUM_MAX) {
		return;
	}

	// 登録処理を行う内容か確認（二重登録のガード）
	if( (ERR_CHK[moj][uno] == knd) && (err_ctl == 0) ){					// ｴﾗｰ内容に変化がなく、
																		// 変化無し時は登録処理を行はない指示の場合
		return;															// 処理終了
	}																	// ERR_CHK[] には 1=発生中，0=未発生の値が入る

	/* 本機で有効なｴﾗ-かﾁｪｯｸ */
	if( !ErrAct[moj][uno].USHORT ){										// 未定義ｴﾗｰ
		return;
	}

	// ** 有効エラーと判定 **

	/* LOG登録準備ｴﾘｱにﾃﾞｰﾀｾｯﾄ */
	memcpy( &Err_work.Date_Time, date, sizeof( date_time_rec ) );		// 発生日時
	Err_work.Errsyu = md;												// ｴﾗｰ種別
	if (minus) {
		Err_work.Errcod = (uchar)(uno+100);								// ｴﾗｰｺｰﾄﾞ
	} else {
		Err_work.Errcod = uno;											// ｴﾗｰｺｰﾄﾞ
	}
	Err_work.Errdtc = knd;												// ｴﾗｰ発生/解除
	Err_work.Errlev = ErrAct[moj][uno].BIT.Level;						// ｴﾗｰﾚﾍﾞﾙ
	Err_work.ErrDoor = 0;
	if( OPE_Is_DOOR_ERRARM && OPECTL.f_DoorSts ){
		Err_work.ErrDoor = ERR_LOG_DOOR_STS_F;							// ドア開状態とする
		if( avm_alarm_flg != 0 ){
			// 警報発砲中
			Err_work.ErrDoor = 0;										// ドア閉状態とする
		}
	}
	Err_work.Errinf = (uchar)f_data;									// ｴﾗｰ情報有無
	if( 1 == f_data )													// 付属ﾃﾞｰﾀ(ascii)あり
// MH810100(S) S.Nishimoto 2020/04/08 静的解析(20200407:222)対応
//		memcpy( &Err_work.Errdat, pData, ERR_LOG_ASC_DAT_SIZE );	// ascii ｴﾗｰ情報をｾｯﾄ
		memcpy( &Err_work.Errdat, pData, length );					// ascii ｴﾗｰ情報をｾｯﾄ
// MH810100(E) S.Nishimoto 2020/04/08 静的解析(20200407:222)対応
	else if( 2 == f_data ){												// 付属ﾃﾞｰﾀ(bin)あり
		memcpy(&Err_work.ErrBinDat,pData,sizeof( Err_work.ErrBinDat ));		// bin ｴﾗｰ情報をｾｯﾄ
	}
	/* Err_work ｴﾘｱは使用後もｸﾘｱしない（問題ないため） */

	// LOG登録
	switch( ErrAct[moj][uno].BIT.LogRegist ){
	case	1:															// LOG登録必要
		f_LogRegist = 1;
		Log_regist( LOG_ERROR );										// ｴﾗｰﾛｸﾞ登録
		break;
	default:
		break;
	}

	/** 運転継続不可能な致命的エラーの場合、LOG登録のみを行い装置Resetする **/
	if( (md == ERRMDL_MAIN) && (uno == ERR_MAIN_MESSAGEFULL) && (knd == 1) ){	// ﾒｰﾙｷｭｰFullｴﾗｰ
		System_reset();													// Main CPU reset (It will not retrun from this function)
	}

	/* Hostへ通知が必要（通信電文送信）*/
	switch( ErrAct[moj][uno].BIT.NoticeToHost ){
	case	2:															// 条件付LOG登録必要（現在なし）
	default:
		break;
	}

	/* ジャーナル印字 */
	switch( ErrAct[moj][uno].BIT.Journal ){
	case	2:															// 条件付ｼﾞｬｰﾅﾙ出力（現在なし）
	case	1:															// ｼﾞｬｰﾅﾙ出力必要
		if( f_LogRegist ){												// LOG登録しないとｼﾞｬｰﾅﾙ印字できない
			if( PrnJnlCheck() == ON ){									//	ｼﾞｬｰﾅﾙﾌﾟﾘﾝﾀ接続ありの場合
				// NOTE:ERR_LOG_DATは印字バッファとして使用する
				memcpy( &ERR_LOG_DAT.Err_log_dat[ERR_LOG_DAT.Err_wtp], &Err_work, sizeof( Err_log ) );
				level = ERR_LOG_DAT.Err_log_dat[ERR_LOG_DAT.Err_wtp].Errlev;	// エラーレベルセット
				if (level >= (uchar)prm_get(COM_PRM, S_PRN, 18, 1, 3)) {
					ErrJouPreqData.prn_kind = J_PRI;											// 出力ﾌﾟﾘﾝﾀ（ｼﾞｬｰﾅﾙ）
					ErrJouPreqData.prn_data = &ERR_LOG_DAT.Err_log_dat[ ERR_LOG_DAT.Err_wtp ];		// ﾃﾞｰﾀﾎﾟｲﾝﾀｾｯﾄ
					queset( PRNTCBNO, PREQ_ERR_JOU, sizeof(T_FrmErrJou), &ErrJouPreqData );		// 印字要求ﾒｯｾｰｼﾞ登録
				}
				ERR_LOG_DAT.Err_wtp++;	/* ﾗｲﾄﾎﾟｲﾝﾀ +1 */
				if( ERR_LOG_DAT.Err_wtp >= ERR_LOG_CNT ){
					ERR_LOG_DAT.Err_wtp = 0;
				}
			}
		}
		break;
	default:
		break;
	}

	IFM_Snd_Error();

	if( f_return ){														// 1=Host送信かジャーナル印字が条件付の場合途中で終了する
		return;
	}

	/* 発生/復旧時の処理 */
	if( 2 == knd )														// 発生&復旧ｴﾗｰの場合はここまで
		return;

	wk_Err_onf = Err_onf;

	// ** 発生時の処理 **

	// ---------------------- //
	// エラー発生
	// ---------------------- //
	if( 1 == knd ){
		ERR_CHK[moj][uno] = knd;	// エラー状況登録
		// binデータあり？
		if( 2 == f_data ){
			ERR_INFO[moj][uno] = Err_work.ErrBinDat;
		}

		Err_onf = 1;	// 現在発生中ｴﾗｰ有り情報ｾｯﾄ

		// ** トラブル信号出力 **
		switch( ErrAct[moj][uno].BIT.TroubleSigOut ){
			// 条件付出力
			case 2:
				if ((md == ERRMDL_REMOTE) && (no == 1)) {
					if( !_is_Normal_pip() ){
						break;	// ParkiPRO接続無し
					}
					if (prm_get(COM_PRM, S_CEN, 12, 1, 1) == 1) {
						break;	// トラブル信号出力しない
					}
				} else {
					break;	// 現在トラブル信号出力は遠隔(55)のHost側通信エラー(1)のみ
				}
			// 出力必要
			case 1:
				if(((md == ERRMDL_LANIBK) && (no == 1)) ||
					((md == ERRMDL_FOMAIBK) && (no == 1))){
					if(prm_get(COM_PRM, S_NTN, 121, 1, 1)) {
						break;	// 駐車場センター形式時のE7201,E7701はトラブル信号出力しない
					}
				}
				Err_trb = 1;												// ﾄﾗﾌﾞﾙ有り(ﾄﾗﾌﾞﾙ信号出力指示)
				break;
			default:
				break;
		}

		// ** 休業ﾁｪｯｸ (条件付の項目はopncls()でﾁｪｯｸする) **

		// 休業指定？
		if( 1 == ErrAct[moj][uno].BIT.Close ){
			Err_cls = 1;	// 休業要因あり
		}
	}

	// ** ｴﾗｰ復旧時の処理 **

	// ---------------------- //
	// エラー復旧
	// ---------------------- //
	else if( 0 == knd ){

		/* ｴﾗｰ発生状況登録 */
		ERR_CHK[moj][uno] = knd;	// エラー状況登録
		ERR_INFO[moj][uno] = 0;

		/* 残りｴﾗｰ発生状況ﾁｪｯｸ */
		onf = trb = cls = 0;
		for( i = 0; i < ERR_MOD_MAX; i++ ){
			for( j = 1; j < ERR_NUM_MAX; j++ ){
				if( ERR_CHK[i][j] != 0 ){								// 現在発生中のｴﾗｰあり
					onf = 1;											// まだ発生中ｴﾗｰあり

					if( 1 == ErrAct[i][j].BIT.TroubleSigOut ){			// 発生中のｴﾗｰはﾄﾗﾌﾞﾙ信号出力要因
						trb = 1;										// ﾄﾗﾌﾞﾙ信号出力要因まだあり
					}
					else if( 2 == ErrAct[i][j].BIT.TroubleSigOut ){		// 発生中のｴﾗｰは条件付でﾄﾗﾌﾞﾙ信号出力要因
						/* 条件ﾁｪｯｸ */
						if ((ErrAct_index[i] == ERRMDL_REMOTE) && (j == 1)) {	// E5501
							if( _is_Normal_pip() &&								// ParkiPRO接続あり かつ
								(prm_get(COM_PRM, S_CEN, 12, 1, 1) == 0) ) 		// トラブル信号出力する
							{
								/* 信号出力条件を満たしていたら以下実施 */
								trb = 1;										// ﾄﾗﾌﾞﾙ信号出力要因まだあり
							}
						}
					}
					/* 休業ﾁｪｯｸ (条件付の項目はopncls()でﾁｪｯｸする) */
					if( 1 == ErrAct[i][j].BIT.Close ){					// 休業指定
						cls = 1;										// 休業要因まだあり
					}
				}
			}
		}
		if( onf == 0 ){													// 現在発生中のｴﾗｰが無くなった
			Err_onf = 0;												// 現在発生中ｴﾗｰなし
		}
		if( trb == 0 ){													// 現在発生中のﾄﾗﾌﾞﾙ信号出力要因ｴﾗｰが無くなった
			Err_trb = 0;												// ﾄﾗﾌﾞﾙなし
		}
		if( cls == 0 ){													// 現在発生中の休業要因ｴﾗｰが無くなった
			Err_cls = 0;												// 休業要因ｴﾗｰなし（条件付以外のもの）
		}
	}

	/* ｴﾗｰ有無状況 変化あり */
	if( wk_Err_onf != Err_onf )											// 発生状況変化あり
		queset( OPETCBNO, MID_STSCHG_ANY_ERROR, 0, NULL );				// OpeMainへ通知

	/* 休業ﾁｪｯｸ */
	switch( ErrAct[moj][uno].BIT.Close ){
	case	2:															// 条件付出力
	case	1:															// 出力必要
		/* 休業要因ｴﾗｰに変化あり */
		queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );					// OpeMainへ通知
		/* 発生要因に対する休業ﾁｪｯｸはOpe主ﾓｼﾞｭｰﾙにて行う opncls() */
		break;
	}
}
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加))

const t_EAM_Act	AlmAct[ALM_MOD_MAX][ALM_NUM_MAX] = {						/* ｴﾗｰｺｰﾄﾞ表ﾓｼﾞｭｰﾙｺｰﾄﾞに対応	*/
//		0		1		2		3		4		5		6		7		8		9 
	{	// 00
		0x0000, 0x5545, 0x0000, 0x0000, 0x0000, 0x5545, 0x5545, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
// MH322916(S) A.Iiizumi 2018/05/16 長期駐車検出機能対応
//		0x5045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x5045, 0x5045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
// MH322916(E) A.Iiizumi 2018/05/16 長期駐車検出機能対応
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
	{	// 01
// MH810105(S) MH364301 インボイス対応
//		0x0000, 0x3045, 0x3045, 0x4120, 0x4100, 0x0000, 0x4065, 0x4165, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x3065, 0x3065, 0x4120, 0x4100, 0x0000, 0x4065, 0x4165, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
// MH810105(E) MH364301 インボイス対応
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4065, 0x4065, 0x4065, 0x4065, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x4045, 0x4045, 0x4045, 0x4045, 0x0000, 0x4045, 0x0000, 0x3045, 0x3045, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x4045, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
// MH810104 GG119201(S) 電子ジャーナル対応
//		0x0000, 0x0000, 0x0000, 0x3045, 0x3045, 0x0000, 0x3045, 0x3045, 0x3045, 0x3045, 	/* ｺｰﾄﾞ：40〜49 */
//		0x0000, 0x0000, 0x0000, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 	/* ｺｰﾄﾞ：40〜49 */
// MH810105(S) MH364301 インボイス対応
//		0x0000, 0x0000, 0x0000, 0x3045, 0x0000, 0x3045, 0x3045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x3045, 0x0000, 0x3065, 0x3045, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
// MH810105(E) MH364301 インボイス対応
// MH810104 GG119201(E) 電子ジャーナル対応
// MH810105(S) MH364301 インボイス対応（プリンタオープンも印字出力判定に追加する）
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0820, 0x0820, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
// MH810105(E) MH364301 インボイス対応（プリンタオープンも印字出力判定に追加する）
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
// MH321800(S) D.Inaba ICクレジット対応 (決済リーダアラームレベル)
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
//		0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
// MH810105 GG119202(S) リーダから直取中の状態データ受信した際の新規アラームを設ける
//		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4045, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x3045, 0x0000, 0x0000, 0x0000, 0x0000, 0x4045, 	/* ｺｰﾄﾞ：80〜89 */
// MH810105 GG119202(E) リーダから直取中の状態データ受信した際の新規アラームを設ける
		0x4045, 0x0000, 0x0000, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
// MH321800(E) D.Inaba ICクレジット対応 (決済リーダアラームレベル)
	},
	{	// 02
		0x0000, 0x4041, 0x4041, 0x4041, 0x4041, 0x0000, 0x0000, 0x4041, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x4041, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x4041, 0x4041, 0x4041, 0x4041, 0x1041, 0x1041, 0x4041, 0x1041, 0x1041, 0x4041, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x4045, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4005, 0x4005, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1045, 0x1041, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// MH810100(S)
	{	// 05
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0041, 0x0041, 0x0041, 0x0041, 0x0041, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：90〜99 */
	},
// GG124100(S) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
	{	// 08
		0x0000, 0x0041, 0x0041, 0x0041, 0x0041, 0x0041, 0x0041, 0x0041, 0x0041, 0x0041, 	/* ｺｰﾄﾞ： 0〜 9 */
		0x0041, 0x0041, 0x0041, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 	/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,		/* ｺｰﾄﾞ：90〜99 */
	},
// GG124100(E) R.Endo 2022/09/12 車番チケットレス3.0 #6343 クラウド料金計算対応
// MH810100(E)
// GG124100(S) R.Endo 2022/08/29 車番チケットレス3.0 #6560 再起動発生（直前のエラー：メッセージキューフル E0011） [共通改善項目 No1528]
#ifdef DEBUG_ALARM_ACT
	{
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ： 0〜 9 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：10〜19 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：20〜29 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：30〜39 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：40〜49 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：50〜59 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：60〜69 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：70〜79 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 			/* ｺｰﾄﾞ：80〜89 */
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, DEBUG_ALARM_ACT,	/* ｺｰﾄﾞ：90〜99 */
	},
#endif
// GG124100(E) R.Endo 2022/08/29 車番チケットレス3.0 #6560 再起動発生（直前のエラー：メッセージキューフル E0011） [共通改善項目 No1528]
};	/* ※休業要因の設定内容ﾁｪｯｸは opncls() で行う。条件変更時は opncls() も変更すること */

/*==== Memo ============================================================================*/
/*	0103 コイン釣銭切れ，0104 コイン釣銭切れ予告 は 本関数 及び テーブルを使用しない。	*/
/*	GT4700ではより細かい項目（0115〜0118）でアラームを収集し本関数がCallされる。		*/
/*	0103 及び 0104 の発生有無は 0105〜0124アラームの縮退結果となるが、これは sig_chk()	*/
/*	内で発生有無チェックとトラブル信号出力を行っている。								*/
/*	釣銭切れ時に休業とするか否かのチェックは opncls() で行っている。					*/
/*======================================================================================*/

/*[]----------------------------------------------------------------------[]*/
/*| Alarm Check & Loging                                                   |*/
/*| 付属情報なし時のｱﾗｰﾑ登録処理                                           |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : alm_chk( md, no, knd )                                  |*/
/*| PARAMETER    : md   : Alarm Module Code (00-99)                        |*/
/*|              : no   : Alarm No. (1-99)                                 |*/
/*|              : knd  : 0=解除 1=発生 2=発生解除                         |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(GT4700より流用)                                    |*/
/*| Date         : 2006-02-16                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2006 AMANO Corp.---[]*/
void	alm_chk( char md, char no, char knd )
{
	alm_chk2( md, no, knd, 0, 0, (void*)0L );
}
// GM849100(S) 名鉄協商コールセンター対応（NT-NET端末間通信）（FT-4000N：MH364304流用）
// AlmActテーブルのインデックスをアラーム種別に変換するテーブル(今後アラーム種別が追加された時用に対応)
static const unsigned char	ALM_MD_COD[ALM_MOD_MAX] = { { 0 },// アラーム種別1 ALMMDL_MAIN
														{ 1 },// アラーム種別2 ALMMDL_SUB
														{ 2 },// アラーム種別3 ALMMDL_SUB2
};
//[]----------------------------------------------------------------------[]
///	@brief			アラームデータ(データ種別121)送信対象の判定処理
//[]----------------------------------------------------------------------[]
///	@param[in]		Armsyu    : アラーム種別
///	@param[in]		Armcod    : アラームコード
///	@return			ret       : 0送信対象外、1送信対象
///	@author			A.iiizumi
///	@attention		
///	@note			
//[]----------------------------------------------------------------------[]
///	@date			Create	: 2012/02/15<br>
///					Update	: 
//[]------------------------------------- Copyright(C) 2012 AMANO Corp.---[]
uchar chk_arm_send_ntnet(uchar Armsyu, uchar Armcod)
{
	uchar	ret = 0;
	int	i;
	
	if( (Armsyu == 255) && (Armcod == 255) ){
		return(1);// アラーム全解除の場合は対象とする
	}
	if( Armcod >= ALM_NUM_MAX ){
		return(ret);// アラームコードが異常の場合対象外
	}

	for(i = 0; i < ALM_MOD_MAX; i++){
		if(Armsyu == ALM_MD_COD[i] ){// 該当するアラーム種別有り
			if( AlmAct[i][Armcod].BIT.NoticeToHost == 1){// 通知が必要
				ret = 1;// 送信対象
			}
		}
	}
	return(ret);// 該当アラーム種別が無い場合対象外
}
// GM849100(E) 名鉄協商コールセンター対応（NT-NET端末間通信）（FT-4000N：MH364304流用）
/*[]----------------------------------------------------------------------[]*/
/*| Error Check & Loging                                                   |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : alm_chk2( md, no, knd, f_data, err_ctl, pData )         |*/
/*| PARAMETER    : md      : Alarm Module Code (00-99)                     |*/
/*|              : no      : Alarm No. (1-99)                              |*/
/*|              : knd     : 0=解除 1=発生 2=発生解除                      |*/
/*|              : f_data  : 0=ｴﾗｰ情報無し 1=ｴﾗｰ情報有り(ascii) 2:(bin)    |*/
/*|              : err_ctl : 0:発生中ﾁｪｯｸする 1:しない                     |*/
/*|                          0=状態変化なし時は登録動作をしない            |*/
/*|              : pData   : 登録する付属ﾃﾞｰﾀへのﾎﾟｲﾝﾀ                     |*/
/*|                          f_data≠0時のみ有効                           |*/
/*|                          f_data=1(ascii)時は、uchar[160]へのﾎﾟｲﾝﾀ      |*/
/*|                          f_data=2(bin)時は、ulongへのﾎﾟｲﾝﾀ             |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(GT4700より流用)                                    |*/
/*| Date         : 2006-02-16                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2006 AMANO Corp.---[]*/
void	alm_chk2( char md, char no, char knd, char f_data, char err_ctl, void *pData )
{
	int		i, j;
	int		onf, trb, cls, bigh;
	T_FrmArmJou		ArmJouPreqData;										// 印字要求用ﾊﾞｯﾌｧ
	uchar	f_LogRegist=0;												// 1=LOG登録済み
	char	wk_Alm_onf;
	char	Security_flag=0;
	uchar	level;														// アラームログのレベル
// GM849100(S) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
	uchar	ErrNo = 0;
// GM849100(E) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信

// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//	/* 登録ｂﾌ有効性チェック */
//	if(( md >= ALM_MOD_MAX )||( no >= ALM_NUM_MAX )){
//		return;
//	}
//	/* 登録処理を行う内容か確認（二重登録のガード）*/
//	if( (ALM_CHK[md][no] == knd) && (err_ctl == 0) ){					// ｴﾗｰ内容に変化がなく、
//																		// 変化無し時は登録処理を行はない指示の場合
//		return;															// 処理終了
//	}
	char moj;

	// 登録ｂﾌ有効性チェック
	moj = alm_moj[md];
	if( moj == (char)-1 ){													// 各ﾓｼﾞｭｰﾙｂﾌ格納場所
		return;
	}
	if (moj >= ALM_MOD_MAX) {
		return;
	}
	if (no >= ALM_NUM_MAX) {
		return;
	}

	// 登録処理を行う内容か確認（二重登録のガード）*/
	if( (ALM_CHK[moj][no] == knd) && (err_ctl == 0) ){					// ｴﾗｰ内容に変化がなく、
																		// 変化無し時は登録処理を行はない指示の場合
		return;															// 処理終了
	}
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))

	if( (rt_ctrl.param.no != 0) || (rt_ctrl.nrml_strt == ON) ){
		return;															// 料金シミュレータで動作中は登録しない
	}

	// 登録されていないｱﾗｰﾑ（ﾌﾟﾘﾝﾀ&ｼﾞｬｰﾅﾙ蓋開）を記録するためﾁｪｯｸを外す
	///* 本機で有効なｱﾗｰﾑかﾁｪｯｸ */
	//if( !AlmAct[md][no].USHORT ){										// 未定義ｴﾗｰ
	//	return;
	//}

	// 精算中に発生したNGカードのアラーム情報を保持しておく
	if(OPECTL.op_faz < 2) {												// 精算・入金中
		if(md == ALMMDL_SUB2) {
			NgCard = no;
		}
	}

	/** 有効アラームと判定 **/

	/* LOG登録準備ｴﾘｱにﾃﾞｰﾀｾｯﾄ */
	memcpy( &Arm_work.Date_Time, &CLK_REC, sizeof( date_time_rec ) );	// 発生日時
	Arm_work.Armsyu = md;												// ｱﾗｰﾑ種別
	Arm_work.Armcod = no;												// ｱﾗｰﾑｺｰﾄﾞ
	Arm_work.Armdtc = knd;												// ｱﾗｰﾑ発生/解除
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//	Arm_work.Armlev = AlmAct[md][no].BIT.Level;							// ｱﾗｰﾑﾚﾍﾞﾙ
	Arm_work.Armlev = AlmAct[moj][no].BIT.Level;						// ｱﾗｰﾑﾚﾍﾞﾙ
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
	Arm_work.ArmDoor = 0;												// ドア閉状態
	if( OPE_Is_DOOR_ERRARM && OPECTL.f_DoorSts ){
		Arm_work.ArmDoor = ERR_LOG_DOOR_STS_F;							// ドア開状態とする
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//		if( AlmAct[md][no].BIT.BigHorn || (avm_alarm_flg != 0) ){
		if( AlmAct[moj][no].BIT.BigHorn || (avm_alarm_flg != 0) ){
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
			// 警報イベントまたは警報発砲中
			Arm_work.ArmDoor = 0;										// ドア閉状態とする
		}
	}
	Arm_work.Arminf = f_data;											// ｱﾗｰﾑ情報有無
	if( 1 == f_data )													// 付属ﾃﾞｰﾀ(ascii)あり
		memcpy( &Arm_work.Armdat, pData, ALM_LOG_ASC_DAT_SIZE );		// ascii ｴﾗｰ情報をｾｯﾄ
	else if( 2 == f_data )												// 付属ﾃﾞｰﾀ(bin)あり
		Arm_work.ArmBinDat = (ulong)(*(ulong*)pData);					// bin ｴﾗｰ情報をｾｯﾄ
	/* Arm_work ｴﾘｱは使用後もｸﾘｱしない（問題ないため） */

// GM849100(S) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信
	// アラームコードをエラー９６ｘｘに変換する
	for( ErrNo = 0; ErrNo < ERR_NUM_MAX; ErrNo++ ) {
		// 該当するアラームコードあり⇒エラーＮｏ検索終了
		if( (Alarm_Err96[ErrNo][0] == Arm_work.Armsyu) && 
				(Alarm_Err96[ErrNo][1] == Arm_work.Armcod) ) {
			Arm_work.Armdat[35] = ErrNo;

			// ここでエラーログに登録
			err_chk2(ERRMDL_ALARM, ErrNo, knd, f_data, err_ctl, pData);

			break;
		}
	}
// GM849100(E) M.Fujikawa 2025/01/21 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信

	/* BIGホーン鳴動 */
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//	if( (AlmAct[md][no].BIT.BigHorn) && (1==knd) ){						// ﾋﾞｯｸﾞﾎﾝ発砲要因発生
	if( (AlmAct[moj][no].BIT.BigHorn) && (1==knd) ){						// ﾋﾞｯｸﾞﾎﾝ発砲要因発生
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
		if(avm_alarm_flg == 0){
			ope_anm(AVM_BOO);
		}
	}

	/* LOG登録 */
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//	switch( AlmAct[md][no].BIT.LogRegist ){
	switch( AlmAct[moj][no].BIT.LogRegist ){
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
	case	1:															// LOG登録必要
		f_LogRegist = 1;
		Log_regist( LOG_ALARM );										// ｱﾗｰﾑﾛｸﾞ登録
		break;
	default:
		break;
	}

	/* ジャーナル印字 */
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//	switch( AlmAct[md][no].BIT.Journal ){
	switch( AlmAct[moj][no].BIT.Journal ){
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
	//case	2:															// 条件付ｼﾞｬｰﾅﾙ出力（現在なし）
	//	;
	case	1:															// ｼﾞｬｰﾅﾙ出力必要
		if( f_LogRegist ){												// LOG登録しないとｼﾞｬｰﾅﾙ印字できない
			if( PrnJnlCheck() == ON ){									//	ｼﾞｬｰﾅﾙﾌﾟﾘﾝﾀ接続ありの場合
// MH322917(S) A.Iiizumi 2018/09/03 長期駐車検出機能の拡張対応(検出部分)
				if(prm_get( COM_PRM, S_PRN, 33, 1, 1 ) != 0 ){	// 18-0033E長期駐車アラームジャーナル印字 しない
					// 長期駐車アラームは一度に大量に発生／解除となりジャーナル印字されるケースがあるため抑止するための機能
					if((Arm_work.Armsyu == ALMMDL_MAIN)&&
					   (Arm_work.Armcod == ALARM_LONG_PARKING)){
						break;// A0031登録 長期駐車検出の印字をマスクする
					}
				}
// MH322917(E) A.Iiizumi 2018/09/03 長期駐車検出機能の拡張対応(検出部分)
				memcpy( &ARM_LOG_DAT.Arm_log_dat[ARM_LOG_DAT.Arm_wtp], &Arm_work, sizeof( Arm_log ) );
				level = ARM_LOG_DAT.Arm_log_dat[ARM_LOG_DAT.Arm_wtp].Armlev;	// アラームレベルセット
				if (level >= (uchar)prm_get(COM_PRM, S_PRN, 18, 1, 4)) {
					ArmJouPreqData.prn_kind = J_PRI;											// 出力ﾌﾟﾘﾝﾀ（ｼﾞｬｰﾅﾙ）
					ArmJouPreqData.prn_data = &ARM_LOG_DAT.Arm_log_dat[ ARM_LOG_DAT.Arm_wtp ];		// ﾃﾞｰﾀﾎﾟｲﾝﾀｾｯﾄ
					queset( PRNTCBNO, PREQ_ARM_JOU, sizeof(T_FrmArmJou), &ArmJouPreqData );		// 印字要求ﾒｯｾｰｼﾞ登録
				}
				ARM_LOG_DAT.Arm_wtp++;	/* ﾗｲﾄﾎﾟｲﾝﾀ +1 */
				if( ARM_LOG_DAT.Arm_wtp >= ARM_LOG_CNT ){
					ARM_LOG_DAT.Arm_wtp = 0;
				}
			}
		}
		break;
	default:
		break;
	}

	/* 発生/復旧時の処理 */
	if( 2 == knd )														// 発生&復旧ｴﾗｰの場合はここまで
		return;

	/* 発生状況登録 */
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_変更))
//	ALM_CHK[md][no] = knd;												// ｱﾗｰﾑ発生状況登録
	ALM_CHK[moj][no] = knd;												// ｱﾗｰﾑ発生状況登録

	// 警告通知(lcdbm_notice_alm)のcall元の追加
	// 警告通知	事象	0=解除､1=発生(警告通知が変化した時のみ送信する)
	// 		ﾚｼｰﾄﾌﾟﾘﾝﾀ		ALM_CHK[1][60]
	// 		ｼﾞｬｰﾅﾙﾌﾟﾘﾝﾀ		ALM_CHK[1][61]
	lcdbm_notice_alm( lcdbm_alarm_check() );
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_変更))
// MH322914(S) K.Onodera 2016/09/07 AI-V対応：エラーアラーム
	if( 1 == knd ){
		if( 2 == f_data ){	// binデータあり？
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_変更))
//			ALM_INFO[md][no] = Arm_work.ArmBinDat;
			ALM_INFO[moj][no] = Arm_work.ArmBinDat;
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_変更))
		}
	}else{
		// 解除時は全てクリアしておく
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_変更))
//		ALM_INFO[md][no] = 0;
		ALM_INFO[moj][no] = 0;
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_変更))
	}
// MH322914(E) K.Onodera 2016/09/07 AI-V対応：エラーアラーム

	wk_Alm_onf = Alm_onf;												// 現 発生状況save

		if( md == ALMMDL_MAIN && ( no == ALARM_VIBSNS || no == ALARM_DOORALARM || no == ALARM_NOTERE_REMOVE )){
			for( i = 1; i < 32; i+=2 ){
				if( CPrmSS[S_OTP][i] == 25 ){
					Security_flag = 1;
					break;
				}
			}
		}

	/* 発生時の処理 */
	if( 1 == knd ){														// ｴﾗｰ発生
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//		if( !AlmAct[md][no].BIT.Mukou )									// 無効ｱﾗｰﾑでない
		if( !AlmAct[moj][no].BIT.Mukou )								// 無効ｱﾗｰﾑでない
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
			Alm_onf = 1;												// 現在発生中ｱﾗｰﾑ有り情報ｾｯﾄ

		/* トラブル信号出力 */
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//		switch( AlmAct[md][no].BIT.TroubleSigOut ){
		switch( AlmAct[moj][no].BIT.TroubleSigOut ){
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
		//case	2:														// 条件付出力（現在なし）
		//	;
		case	1:														// 出力必要
			if( Security_flag ){
				Security_out = 1;										// 防犯センサー出力指示
			}else
			Alm_trb = 1;												// ﾄﾗﾌﾞﾙ有り(ﾄﾗﾌﾞﾙ信号出力指示)
			break;
		default:
			break;
		}

		/* 休業ﾁｪｯｸ (条件付の項目はopncls()でﾁｪｯｸする) */
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//		if( 1 == AlmAct[md][no].BIT.Close ){							// 休業指定
		if( 1 == AlmAct[moj][no].BIT.Close ){							// 休業指定
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))			
			Alm_cls = 1;												// 休業要因あり
		}
	}

	/* ｱﾗｰﾑ復旧時の処理 */
	 if( 0 == knd ){													// ｱﾗｰﾑ復旧

		/* 残りｱﾗｰﾑ発生状況ﾁｪｯｸ */
		onf = trb = bigh = cls = 0;
		for( i = 0; i < ALM_MOD_MAX; i++ ){
			for( j = 1; j < ALM_NUM_MAX; j++ ){
				if( ALM_CHK[i][j] != 0 ){								// 現在発生中のｴﾗｰあり
					if( !AlmAct[i][j].BIT.Mukou )						// 無効ｱﾗｰﾑでない
						onf = 1;										// まだ発生中ｴﾗｰあり

					if( 1 == AlmAct[i][j].BIT.TroubleSigOut ){			// 発生中のｱﾗｰﾑはﾄﾗﾌﾞﾙ信号出力要因
						trb = 1;										// ﾄﾗﾌﾞﾙ信号出力要因まだあり
					}
					//else if( 2 == AlmAct[i][j].BIT.TroubleSigOut ){	// 発生中のｴﾗｰは条件付でﾄﾗﾌﾞﾙ信号出力要因（現在なし）
					//	/* 条件ﾁｪｯｸ */
					//	/* 信号出力条件を満たしていたら以下実施 */
					//	//trb = 1;										// ﾄﾗﾌﾞﾙ信号出力要因まだあり
					//}

					/* 休業ﾁｪｯｸ (条件付の項目はopncls()でﾁｪｯｸする) */
					if( 1 == AlmAct[i][j].BIT.Close ){					// 休業指定
						cls = 1;										// 休業要因まだあり
					}

					if( AlmAct[i][j].BIT.BigHorn ){						// 発生中のｴﾗｰはﾋﾞｯｸﾞﾎｰﾝ出力要因
						bigh = 1;										// ﾋﾞｯｸﾞﾎｰﾝ出力要因まだあり
					}
				}
			}
		}
		if( onf == 0 ){													// 現在発生中のｱﾗｰﾑが無くなった
			Alm_onf = 0;												// 現在発生中ｱﾗｰﾑなし
		}
		if( trb == 0 ){													// 現在発生中のﾄﾗﾌﾞﾙ信号出力要因ｱﾗｰﾑが無くなった
			if( Security_flag )
				Security_out = 0;										// 防犯センサー出力解除
			else
				Alm_trb = 0;											// ﾄﾗﾌﾞﾙなし
		}
		if( cls == 0 ){													// 現在発生中の休業要因ｴﾗｰが無くなった
			Alm_cls = 0;												// 休業要因ｱﾗｰﾑなし（条件付以外のもの）
		}
		if( bigh == 0 ){												// 現在発生中のﾋﾞｯｸﾞﾎｰﾝ出力要因ｱﾗｰﾑが無くなった
			if(avm_alarm_flg)
			ope_anm(AVM_BOO);
		}
	}

	/* ｴﾗｰ有無状況 変化あり */
	if( wk_Alm_onf != Alm_onf )											// 発生状況変化あり
		queset( OPETCBNO, MID_STSCHG_ANY_ALARM, 0, NULL );				// OpeMainへ通知

	/* 休業ﾁｪｯｸ */
// MH810100(S) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
//	switch( AlmAct[md][no].BIT.Close ){
	switch( AlmAct[moj][no].BIT.Close ){
// MH810100(E) Y.Watanabe 2019/11/15 車番チケットレス((LCD_IF対応)_追加)_変更))
	case	2:															// 条件付出力
	case	1:															// 出力必要
		/* 休業要因ｴﾗｰに変化あり */
		queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );					// OpeMainへ通知
		/* 発生要因に対する休業ﾁｪｯｸはOpe主ﾓｼﾞｭｰﾙにて行う opncls() */
		break;
	}
}

/*[]----------------------------------------------------------------------[]*/
/*| Suica Status Check & Error Loging                                      |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_suica_chk( NEW, OLD );                              |*/
/*| PARAMETER    : uchar *NEW : New Status                                 |*/
/*|              : uchar *OLD : Old Status                                 |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Namioka					                               |*/
/*| Date         : 2006-08-10                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2006 AMANO Corp.---[]*/
static const unsigned char	SUICA_ERR_COD[8] = {

	{ ERR_SUICA_COMFAIL },
	{ ERR_SUICA_RECEIVE },
	{ 0 },
	{ 0 },
	{ 0 },
	{ 0 },
	{ 0 },
	{ 0 }
};

void	err_suica_chk( unsigned char *NEW, unsigned char *OLD , unsigned char kind )
{
	short	i;
	unsigned char	ebit;
	unsigned char	*d1, *d2;

	d1 = NEW;
	d2 = OLD;

	ebit = (uchar)(( *d1 ^ *d2 ));
	if( ebit != 0 ){									// ｽﾃ-ﾀｽ変化?
		for( i = 0; i < 8; i++ ){						// 該当ｴﾗｰ検索
			if( SUICA_ERR_COD[i] == kind ){				// 該当ｴﾗｰかどうか
// MH321800(S) D.Inaba ICクレジット対応
//				err_chk( ERRMDL_SUICA, (char)SUICA_ERR_COD[i], (char)( *d1 != 0 ? 1:*d1 ), 0, 0 );	// ｴﾗｰ登録
				if ( isEC_USE() != 0 ) {
				// 決済リーダではERR_SUICA_COMFAIL(ERR_EC_COMFAIL)しか現状チェックしない
// MH321800(S) 切り離しエラー発生後の待機状態でJVMAリセットを行う
//					if (*d1 != 0) {
// MH321800(E) 切り離しエラー発生後の待機状態でJVMAリセットを行う
// GG116202(S) JVMAリセット回数制限対応
					if (*d1 == 0) {								// エラー解除
						if (hasEC_JVMA_RESET_CNT_EXCEEDED) {	// JVMAリセットリトライ回数越え
							break;
						}
					}
// GG116202(E) JVMAリセット回数制限対応
						err_chk((char)jvma_setup.mdl, (char)SUICA_ERR_COD[i], (char)( *d1 != 0 ? 1:*d1 ), 0, 0 );	// ｴﾗｰ登録(発生のみ)
						if (OPECTL.op_faz < 2) {
						// 精算中
// MH321800(S) Y.Tanizaki ICクレジット対応(通信不良の際にSYN信号が1秒間EnableにならずJVMAラインの機器がリセットしない)
// 通信不良になった場合、起動シーケンスからやり直しのため取引終了を送信する必要はない
//							Ec_Pri_Data_Snd(S_CNTL_DATA, 0x80);		// 制御ﾃﾞｰﾀ（取引終了）を送信
// MH321800(E) Y.Tanizaki ICクレジット対応(通信不良の際にSYN信号が1秒間EnableにならずJVMAラインの機器がリセットしない)
						// 送信した選択商品データクリア→以降同一精算内で選択商品データを送信しないようにする
							Suica_Rec.Data.BIT.ADJUSTOR_START = 0;
						}
// MH321800(S) 切り離しエラー発生後の待機状態でJVMAリセットを行う
//					}
// MH321800(E) 切り離しエラー発生後の待機状態でJVMAリセットを行う
				} else {
					err_chk((char)jvma_setup.mdl, (char)SUICA_ERR_COD[i], (char)( *d1 != 0 ? 1:*d1 ), 0, 0 );	// ｴﾗｰ登録
				}
// MH321800(E) D.Inaba ICクレジット対応
				break;
			}
		}
	}
	return;

}

// MH321800(S) G.So ICクレジット対応
/*[]----------------------------------------------------------------------[]*/
/*| Ec Status Check & Error Loging                                         |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_ec_chk( NEW, OLD );                           	   |*/
/*| PARAMETER    : uchar *NEW : New Status                                 |*/
/*|              : uchar *OLD : Old Status                                 |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : G.So						                               |*/
/*| Date         : 2019-01-29                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2019 AMANO Corp.---[]*/
static const unsigned char	EC_ERR_COD[8] = {

	{ ERR_EC_ERR_HARD },
	{ ERR_EC_ERR_DRIVER },
	{ ERR_EC_ERR_SYSTEM },
	{ ERR_EC_ERR_ENCRYPTION },
	{ ERR_EC_ERR_CONNECTION },
	{ 0 },
	{ 0 },
	{ 0 }
};
// MH321800(S) 切り離しエラー発生後の待機状態でJVMAリセットを行う
static const unsigned char	EC_ERR_COD2[8] = {

	{ ERR_EC_RCV_SETT_ERR_100 },
	{ ERR_EC_RCV_SETT_ERR_200 },
	{ ERR_EC_RCV_SETT_ERR_300 },
	{ ERR_EC_RCV_SETT_ERR_305 },
	{ ERR_EC_RCV_SETT_ERR_304 },
	{ 0 },
	{ 0 },
	{ 0 }
};
// MH321800(E) 切り離しエラー発生後の待機状態でJVMAリセットを行う
void	err_ec_chk(unsigned char *NEW, unsigned char *OLD)
{
	short	i;
	unsigned char	bit;
	unsigned char	ebit;
	unsigned char	*d1, *d2;

	d1 = NEW;
	d2 = OLD;

	ebit = (uchar)((*d1 ^ *d2));
	if (ebit != 0) {										// ｽﾃ-ﾀｽ変化?
		for (i = 0; i < 8; i++) {							// 該当ｴﾗｰ検索
			if ((EC_ERR_COD[i] != 0)						// 該当ｴﾗｰかどうか
			&&	(((ebit >> i) & 0x01) != 0)) {				// ｽﾃ-ﾀｽ変化?
				bit = (((*d1 >> i) & 0x01) != 0)? 1 : 0;	// 発生or解除
				if (bit != 0) {
				// 発生
					err_chk((char)jvma_setup.mdl, (char)EC_ERR_COD[i], (char)bit, 0, 0);	// ｴﾗｰ登録
// MH810103 GG119202(S) 未了中に異常データ受信でとりけしボタン押下待ちにならない
//					if (Suica_Rec.Data.BIT.ADJUSTOR_NOW) {
					if (Suica_Rec.Data.BIT.ADJUSTOR_NOW &&
						!Suica_Rec.Data.BIT.CTRL_MIRYO) {
					// 未了中は取引終了を送信しない
// MH810103 GG119202(E) 未了中に異常データ受信でとりけしボタン押下待ちにならない
					// 選択商品データ送信済み
						Ec_Pri_Data_Snd(S_CNTL_DATA, 0x80);		// 制御ﾃﾞｰﾀ（取引終了）を送信
					// 送信した選択商品データクリア→以降同一精算内で選択商品データを送信しないようにする
						Suica_Rec.Data.BIT.ADJUSTOR_START = 0;
					}
				}
			}
		}
	}
	return;

}

// MH321800(S) 切り離しエラー発生後の待機状態でJVMAリセットを行う
// 切り離しエラー全解除
void err_ec_clear(void)
{
	short	i;

// MH321800(S) 切り離しエラー発生後の待機状態でJVMAリセットを行う
	// E3202〜E3206
// MH321800(E) 切り離しエラー発生後の待機状態でJVMAリセットを行う
	for (i = 0; i < 8; i++) {
		if (EC_ERR_COD[i] != 0 && EC_ERR_COD2[i] != 0) {	// 該当ｴﾗｰかどうか
			err_chk((char)jvma_setup.mdl, (char)EC_ERR_COD[i], 0, 0, 0);	// ｴﾗｰ解除
			err_chk((char)jvma_setup.mdl, (char)EC_ERR_COD2[i], 0, 0, 0);	// ｴﾗｰ解除
		}
	}
// MH321800(S) 切り離しエラー発生後の待機状態でJVMAリセットを行う
	// E3259, E3262, E3263
	err_chk((char)jvma_setup.mdl, ERR_EC_SETTLE_ERR, 0, 0, 0);				// ｴﾗｰ解除
	err_chk((char)jvma_setup.mdl, ERR_EC_PAY_ERR, 0, 0, 0);					// ｴﾗｰ解除
	err_chk((char)jvma_setup.mdl, ERR_EC_PAYBRAND_ERR, 0, 0, 0);			// ｴﾗｰ解除
// MH321800(E) 切り離しエラー発生後の待機状態でJVMAリセットを行う
// MH810103 GG119202(S) カード処理中タイムアウトでみなし決済扱いとする
	// E3234
	err_chk((char)jvma_setup.mdl, ERR_EC_RCV_SETT_FAIL, 0, 0, 0);			// ｴﾗｰ解除
// MH810103 GG119202(E) カード処理中タイムアウトでみなし決済扱いとする
// MH810105(S) MH364301 E3249を発生／解除別に変更
	// E3249
	err_chk((char)jvma_setup.mdl, ERR_EC_NOTOK_SETTLE_ERR, 0, 0, 0);		// ｴﾗｰ解除
// MH810105(E) MH364301 E3249を発生／解除別に変更
}
// MH321800(E) 切り離しエラー発生後の待機状態でJVMAリセットを行う
// MH321800(E) G.So ICクレジット対応

// MH810103 GG119202(S) 異常データフォーマット変更
// JVMAリセット対象外エラー（決済リーダー切り離しのみ）
static const unsigned char	EC_ERR_COD3[8] = {
	{ ERR_EC_ERR_LTE_FAIL },
	{ ERR_EC_ERR_SETTING_FAIL },
	{ 0 },
	{ 0 },
	{ 0 },
	{ 0 },
	{ 0 },
	{ 0 }
};
void err_ec_chk2(unsigned char *NEW, unsigned char *OLD)
{
	short	i;
	unsigned char	bit;
	unsigned char	ebit;
	unsigned char	*d1, *d2;

	d1 = NEW;
	d2 = OLD;

	ebit = (uchar)((*d1 ^ *d2));
	if (ebit != 0) {										// ｽﾃ-ﾀｽ変化?
		for (i = 0; i < 8; i++) {							// 該当ｴﾗｰ検索
			if ((EC_ERR_COD3[i] != 0)						// 該当ｴﾗｰかどうか
			&&	(((ebit >> i) & 0x01) != 0)) {				// ｽﾃ-ﾀｽ変化?
				bit = (((*d1 >> i) & 0x01) != 0)? 1 : 0;	// 発生or解除
				if (bit != 0) {
				// 発生
					err_chk((char)jvma_setup.mdl, (char)EC_ERR_COD3[i], (char)bit, 0, 0);	// ｴﾗｰ登録
					if (Suica_Rec.Data.BIT.ADJUSTOR_NOW) {
					// 選択商品データ送信済み
						Ec_Pri_Data_Snd(S_CNTL_DATA, 0x80);		// 制御ﾃﾞｰﾀ（取引終了）を送信
					// 送信した選択商品データクリア→以降同一精算内で選択商品データを送信しないようにする
						Suica_Rec.Data.BIT.ADJUSTOR_START = 0;
					}
				}
			}
		}
	}
}
// MH810103 GG119202(E) 異常データフォーマット変更

/*[]----------------------------------------------------------------------[]*/
/*| Coin-Mech Status Check & Error Loging                                  |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_cn_chk( NEW, OLD );                                 |*/
/*| PARAMETER    : uchar *NEW : New Status                                 |*/
/*|              : uchar *OLD : Old Status                                 |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(NT4500EXより流用)                                  |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
static const unsigned char	CN_ERR_COD[3][8][2] = {
{
	{ 0x01, 0 },
	{ 0x02, 0 },
	{ 0x04, 0 },
	{ 0x08, ERR_COIN_ACCEPTER },
	{ 0x10, ERR_COIN_10EMPTYSW },
	{ 0x20, ERR_COIN_50EMPTYSW },
	{ 0x40, ERR_COIN_100EMPTYSW },
	{ 0x80, ERR_COIN_500EMPTYSW }},
{
	{ 0x01, 0 },
	{ 0x02, 0 },
	{ 0x04, 0 },
	{ 0x08, 0 },
	{ 0x10, ERR_COIN_REJECTSW },
	{ 0x20, ERR_COIN_DISPENCEFAIL },
	{ 0x40, 0 },
	{ 0x80, 0 }},
{
	{ 0x01, ERR_COIN_10OVFSENSOR },
	{ 0x02, ERR_COIN_50VFSENSOR },
	{ 0x04, ERR_COIN_100VFSENSOR },
	{ 0x08, ERR_COIN_500VFSENSOR },
	{ 0x10, 0 },
	{ 0x20, 0 },
	{ 0x40, 0 },
	{ 0x80, 0 }}
};

void	err_cn_chk( unsigned char *NEW, unsigned char *OLD )
{
	int	i, j;
	unsigned char	ebit;
	unsigned char	*d1, *d2;
	char	knd;

	d1 = NEW;
	d2 = OLD;

	for( i = 0; i < 3; i++ ){
		ebit = (uchar)( *d1 ^ *d2 );
		if( ebit != 0 ){												// ｽﾃ-ﾀｽ変化?
			for( j = 0; j < 8; j++ ){
				if( CN_ERR_COD[i][j][1] == 0 ){
					continue;
				}
				if( ebit & CN_ERR_COD[i][j][0] ){						// ｴﾗｰﾋﾞｯﾄﾁｪｯｸ
					knd = !!( *d1 & CN_ERR_COD[i][j][0] );				// 発生/解除
					err_chk( ERRMDL_COIM, (char)CN_ERR_COD[i][j][1], knd, 0, 0 );	// ｴﾗｰ登録
					if (OPECTL.Mnt_mod == 0 &&
						(OPECTL.Ope_mod == 2 || OPECTL.Ope_mod == 3)){	// 精算中
						if( ERR_COIN_DISPENCEFAIL == CN_ERR_COD[i][j][1] ){
							if( knd == 0 ){
								IoLog_write(IOLOG_EVNT_ERR_COINDISPENCEFAIL_Re, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// コイン払出異常 解除
							} else {
								IoLog_write(IOLOG_EVNT_ERR_COINDISPENCEFAIL_Ge, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// コイン払出異常 発生
							}
						}
					}
				}
			}
		}
		d1++;
		d2++;
	}
	return;
}

//[]----------------------------------------------------------------------[]
///	@brief			ｺｲﾝﾒｯｸ故障ﾁｪｯｸ
//[]----------------------------------------------------------------------[]
///	@return			ret : 0=OK -1=故障あり(休業)
///	@author			m.onouchi
//[]----------------------------------------------------------------------[]
///	@date			Create	: 
///					Update	: 
//[]------------------------------------- Copyright(C) 2009 AMANO Corp.---[]
char err_cnm_chk(void)
{
	int	i;

	for (i = 0; i < ERR_NUM_MAX; i++) {
		if (ERR_CHK[mod_coin][i] != 0) {
			if (ErrAct[mod_coin][i].BIT.Close == 1) {
				return (char)-1;
			}
		}
	}
	return 0;
}

/*[]----------------------------------------------------------------------[]*/
/*| Note-Reader Status Check & Error Loging                                |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_nt_chk( NEW, OLD );                                 |*/
/*| PARAMETER    : uchar *NEW : New Status                                 |*/
/*|              : uchar *OLD : Old Status                                 |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(NT4500EXより流用)                                  |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
static const unsigned char	NT_ERR_COD[8][2] = {
	{ 0x01, 0 },
	{ 0x02, 0 },
	{ 0x04, ERR_NOTE_SHIKIBETU },
	{ 0x08, ERR_NOTE_STACKER },
	{ 0x10, ERR_NOTE_JAM },
	{ 0x20, ERR_NOTE_REJECT },
	{ 0x40, 0 },
	{ 0x80, 0 }
};

void	err_nt_chk( unsigned char *NEW, unsigned char *OLD )
{
	short	i;
	unsigned char	ebit;
	unsigned char	*d1, *d2;
	char	knd;

	d1 = NEW;
	d2 = OLD;

	ebit = (uchar)(( *d1 ^ *d2 ) & 0x3c);
	if( ebit != 0 ){												// ｽﾃ-ﾀｽ変化?
		for( i = 0; i < 8; i++ ){
			if( NT_ERR_COD[i][1] == 0 ){
				continue;
			}
			if( ebit & NT_ERR_COD[i][0] ){							// ｴﾗｰﾋﾞｯﾄﾁｪｯｸ
				knd = !!( *d1 & NT_ERR_COD[i][0] );					// 発生/解除
				err_chk( ERRMDL_NOTE, (char)NT_ERR_COD[i][1], knd, 0, 0 );	// ｴﾗｰ登録
				if (OPECTL.Mnt_mod == 0 &&
					(OPECTL.Ope_mod == 2 || OPECTL.Ope_mod == 3)){	// 精算中
					if( ERR_NOTE_JAM == NT_ERR_COD[i][1] ){
						if( knd == 0 ){
							IoLog_write(IOLOG_EVNT_ERR_NOTEJAM_Re, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 紙幣詰り 解除
						} else {
							IoLog_write(IOLOG_EVNT_ERR_NOTEJAM_Ge, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 紙幣詰り 発生
						}
					} else if( ERR_NOTE_REJECT == NT_ERR_COD[i][1] ){
						if( knd == 0 ){
							IoLog_write(IOLOG_EVNT_ERR_NOTEREJECT_Re, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 紙幣払出し異常 解除
						} else {
							IoLog_write(IOLOG_EVNT_ERR_NOTEREJECT_Ge, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 紙幣払出し異常 発生
						}
					}
				}
			}
		}
	}
	return;
}

/*[]----------------------------------------------------------------------[]*/
/*| Printer Status Check & Error Loging                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_pr_chk( NEW, OLD );                                 |*/
/*| PARAMETER    : uchar NEW : New Status                                  |*/
/*|              : uchar OLD : Old Status                                  |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(NT4500EXより流用)                                  |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
static const unsigned char	PR_ERR_COD[8][2] = {
	{ 0x01, ALARM_RPAPERNEAREND },									// ﾆｱｴﾝﾄﾞ
	{ 0x02, ALARM_RPAPEROPEN },										// ｵｰﾌﾟﾝ 
	{ 0x04, ALARM_RPAPEREND },										// ｴﾝﾄﾞ
	{ 0x08, ERR_PRNT_R_HEADHEET },
	{ 0x10, ERR_PRNT_R_CUTTER },
	{ 0x20, 0 },
	{ 0x40, 0 },
	{ 0x80, 0 }
};

void	err_pr_chk( unsigned char NEW, unsigned char OLD )
{
	short	i;
	unsigned char	ebit;
	char	knd;

	ebit = (uchar)(( NEW ^ OLD ) & 0x1f);
	if( ebit != 0 ){												// ｽﾃ-ﾀｽ変化?
		if( NEW & 0x04 ){
			NEW |= 0x01;
			ebit |= 0x01;
		}else{
			if( !( NEW & 0x01 ) ){
				ebit |= 0x01;
			}
		}
		for( i = 0; i < 8; i++ ){
			if( PR_ERR_COD[i][1] == 0 ){
				continue;
			}
			if( ebit & PR_ERR_COD[i][0] ){							// ｴﾗｰﾋﾞｯﾄﾁｪｯｸ
				knd = !!( NEW & PR_ERR_COD[i][0] );					// 発生/解除
				if( i < 3 ){										// ｱﾗｰﾑ発生?
					if( PR_ERR_COD[i][1] != 0 ){
						alm_chk( ALMMDL_SUB, (char)PR_ERR_COD[i][1], knd );		// ｱﾗｰﾑ登録
						if(i == 1){
							Pri_Open_Status_R = knd;
						}
					}
				}else{
					if( PR_ERR_COD[i][1] != 0 ){
						err_chk( ERRMDL_PRINTER, (char)PR_ERR_COD[i][1], knd, 0, 0 );	// ｴﾗｰ登録
					}
				}
			}
		}
	}
	return;
}

/*[]----------------------------------------------------------------------[]*/
/*| Printer Status Check & Error Loging(ｼﾞｬｰﾅﾙ)                            |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_pr_chk2( NEW, OLD );                                |*/
/*| PARAMETER    : uchar NEW : New Status                                  |*/
/*|              : uchar OLD : Old Status                                  |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Motohashi                                               |*/
/*| Date         : 2005-08-10                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
static const unsigned char	PR_ERR_COD2[8][2] = {
	{ 0x01, ALARM_JPAPERNEAREND },		// ﾍﾟｰﾊﾟｰﾆｱｴﾝﾄﾞ
	{ 0x02, ALARM_JPAPEROPEN },			// ﾌﾟﾗﾃﾝｵｰﾌﾟﾝ 
	{ 0x04, ALARM_JPAPEREND },			// ﾍﾟｰﾊﾟｰｴﾝﾄﾞ
	{ 0x08, ERR_PRNT_J_HEADHEET },		// ﾍｯﾄﾞ温度異常
	{ 0x10, 0 },
	{ 0x20, 0 },
	{ 0x40, 0 },
	{ 0x80, 0 }
};

void	err_pr_chk2( unsigned char NEW, unsigned char OLD )
{
	short	i;
	unsigned char	ebit;
	char	knd;

	ebit = (uchar)(( NEW ^ OLD ) & 0x1f);
	if( ebit != 0 ){												// ｽﾃ-ﾀｽ変化?
		if( NEW & 0x04 ){
			NEW |= 0x01;
			ebit |= 0x01;
		}else{
			if( !( NEW & 0x01 ) ){
				ebit |= 0x01;
			}
		}
		for( i = 0; i < 8; i++ ){
			if( ebit & PR_ERR_COD2[i][0] ){							// ｴﾗｰﾋﾞｯﾄﾁｪｯｸ
				knd = !!( NEW & PR_ERR_COD2[i][0] );				// 発生/解除
				if( i < 3 ){										// ｱﾗｰﾑ発生?
					if( PR_ERR_COD2[i][1] != 0 ){
						alm_chk( ALMMDL_SUB, (char)PR_ERR_COD2[i][1], knd );			// ｱﾗｰﾑ登録
						if(i == 1){
							Pri_Open_Status_J = knd;
						}
					}
				}else{
					if( PR_ERR_COD2[i][1] != 0 ){
						err_chk( ERRMDL_PRINTER, (char)PR_ERR_COD2[i][1], knd, 0, 0 );	// ｴﾗｰ登録
					}
				}
			}
		}
	}
	return;
}

// MH810104 GG119201(S) 電子ジャーナル対応
//[]----------------------------------------------------------------------[]
///	@brief			電子ジャーナルエラーチェック
//[]----------------------------------------------------------------------[]
///	@param[in]		NEW		: 現ステータス
///	@param[in]		OLD		: 旧ステータス
///	@return			void
//[]------------------------------------- Copyright(C) 2020 AMANO Corp.---[]
static const uchar	EJA_ERR_COD[8][2] = {
	{ 0x01, ALARM_SD_NEAR_END },		// SDカードニアエンド
	{ 0x02, ERR_EJA_SD_UNAVAILABLE },	// SDカード使用不可
	{ 0x04, ALARM_SD_END },				// SDカードエンド
	{ 0x08, 0 },
	{ 0x10, ALARM_SD_EXPIRATION },		// SDカード使用期限超過
	{ 0x20, 0 },
	{ 0x40, 0 },
	{ 0x80, 0 },
};

void err_eja_chk(uchar NEW, uchar OLD)
{
	short	i;
	uchar	ebit;
	char	knd;

	ebit = (uchar)(( NEW ^ OLD ) & 0x17);
	if( ebit != 0 ){												// ｽﾃ-ﾀｽ変化?
		if( NEW & 0x04 ){
			NEW |= 0x01;
			ebit |= 0x01;
		}else{
			if( !( NEW & 0x01 ) ){
				ebit |= 0x01;
			}
		}
		for( i = 0; i < 8; i++ ){
			if( ebit & EJA_ERR_COD[i][0] ){							// ｴﾗｰﾋﾞｯﾄﾁｪｯｸ
				knd = !!( NEW & EJA_ERR_COD[i][0] );				// 発生/解除
				if( i == 0 || i == 2 || i == 4 ){					// ｱﾗｰﾑ発生?
					if( EJA_ERR_COD[i][1] != 0 ){
						alm_chk( ALMMDL_SUB, (char)EJA_ERR_COD[i][1], knd );		// ｱﾗｰﾑ登録
					}
				}else{
					if( EJA_ERR_COD[i][1] != 0 ){
						err_chk( ERRMDL_EJA, (char)EJA_ERR_COD[i][1], knd, 0, 0 );	// ｴﾗｰ登録
					}
				}
			}
		}
	}
}
// MH810104 GG119201(E) 電子ジャーナル対応

/*[]----------------------------------------------------------------------[]*/
/*| ﾒﾓﾘﾁｪｯｸ（AMANOﾊﾟｽﾜｰﾄﾞのﾁｪｯｸ）										   |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : memorychk( void );                                      |*/
/*| PARAMETER    : void                                                    |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara                                                    |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
void	memorychk( void )
{
	if( memcmp( PASSPT.pas_word, PASSDF.pas_word, sizeof( PASSPT.pas_word )) ){	// ﾊﾟｽﾜｰﾄﾞﾁｪｯｸ
		err_chk( ERRMDL_MAIN, ERR_MAIN_MEMORY, 1, 0, 0 );			// ﾒﾓﾘｴﾗｰ発生
	}else{
		err_chk( ERRMDL_MAIN, ERR_MAIN_MEMORY, 0, 0, 0 );			// ﾒﾓﾘｴﾗｰ解除
	}
}

/*[]----------------------------------------------------------------------[]*/
/*| 操作履歴ﾛｸﾞﾃﾞｰﾀ登録                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : wopelg                                                  |*/
/*| PARAMETER    : no : 操作No.                                            |*/
/*|                before : 変更前データ                                   |*/
/*|                after  : 変更後データ                                   |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : machida kei                                             |*/
/*| Date         : 2005-11-30                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
void	wopelg(ushort no, ulong before, ulong after)
{
	Ope_log *work;
	
	work = &OPE_LOG_DAT.Ope_work;
	memset(work, 0, sizeof(*work));
	memcpy(&work->Date_Time, &CLK_REC, sizeof(date_time_rec));	// 発生日時
	work->OpeKind	= (uchar)(no / 100);						// 種別
	work->OpeCode	= (uchar)(no % 100);						// コード
	work->OpeBefore	= before;									// 変更前データ
	work->OpeAfter	= after;									// 変更後データ
//	work->OpeLevel	= ;		(Log_regist内で取得する)
	Log_regist(LOG_OPERATE);									// 操作履歴ﾛｸﾞ登録
}

/*[]----------------------------------------------------------------------[]*/
/*| モニタデータ登録                                                       |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : wmonlg                                                  |*/
/*| PARAMETER    : no : 操作No.                                            |*/
/*|                p_info, ul_info : モニタ情報                            |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Remark       : p_info/ul_infoともにNT-NET通信フォーマットでいう"モニタ情報" |*/
/*|                に該当する。                                            |*/
/*|                本関数内部ではp_info==NULLであればul_infoをモニタ情報とし、  |*/
/*|                p_info!=NULLであればp_infoをモニタ情報として扱う。      |*/
/*|                バイナリでモニタ情報を渡したい場合は                    |*/
/*|                   p_info = NULL                                        |*/
/*|                   ul_info = モニタ情報                                 |*/
/*|                としてセットすること。                                  |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : machida kei                                             |*/
/*| Date         : 2005-11-30                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
void	wmonlg(ushort no, void *p_info, ulong ul_info)
{
	Mon_log *work;
	
	work = &MON_LOG_DAT.Mon_work;
	memset(work, 0, sizeof(*work));
	memcpy(&work->Date_Time, &CLK_REC, sizeof(date_time_rec));	// 発生日時
	work->MonKind	= (uchar)(no / 100);						// 種別
	work->MonCode	= (uchar)(no % 100);						// コード
	if (p_info != NULL) {
		memcpy(work->MonInfo, p_info, sizeof(work->MonInfo));			// モニタ情報
	}
	else {
		work->MonInfo[6] = (uchar)((ul_info & 0xFF000000) >> (8 * 3));
		work->MonInfo[7] = (uchar)((ul_info & 0x00FF0000) >> (8 * 2));
		work->MonInfo[8] = (uchar)((ul_info & 0x0000FF00) >> (8 * 1));
		work->MonInfo[9] = (uchar)(ul_info & 0x000000FF);
	}
//	work->MonLevel	= ;		(Log_regist内で取得する)
	Log_regist(LOG_MONITOR);									// モニタデータ登録
}

/*[]----------------------------------------------------------------------------------------------[]*/
/*| 信号出力ﾁｪｯｸ																				   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| MODULE NAME	: sig_chk( void );																   |*/
/*| PARAMETER	: void																			   |*/
/*| RETURN VALUE: void																			   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| Author		: R.Hara(AMANO)																	   |*/
/*| Date		: 2001-12-07																	   |*/
/*|	Update		: 2005-06-16 for UT8500 T.Hashimoto												   |*/
/*[]------------------------------------------------------------- Copyright(C) 2001 AMANO Corp.---[]*/
void	sig_chk( void )
{
	int   i;
	unsigned char	dt;
	unsigned char	st;

	if( OPECTL.Ope_Mnt_flg == 8 ) {
		return;												/* Now System Maintenance		*/
	}

	//--------------------------------------------------------------------------------------*/
	//	ﾄﾗﾌﾞﾙ信号出力
	//--------------------------------------------------------------------------------------*/
	if(( Err_trb != 0 )||( Alm_trb != 0 )) {
		Ex_portFlag[EXPORT_TROUBLE] = 1;
	} else {
		Ex_portFlag[EXPORT_TROUBLE] = 0;
	}
	//--------------------------------------------------------------------------------------*/
	//	防犯センサー信号出力
	//--------------------------------------------------------------------------------------*/
	if( Security_out != 0 ) {
		Ex_portFlag[EXPORT_SECURITY] = 1;
	} else {
		Ex_portFlag[EXPORT_SECURITY] = 0;
	}

	//--------------------------------------------------------------------------------------*/
	//	満車
	//--------------------------------------------------------------------------------------*/

		fulchk();						// 現在台数ﾁｪｯｸ

	//--------------------------------------------------------------------------------------*/
	//	ﾚｼｰﾄ紙切れﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	switch( paperchk() ){	// ﾚｼｰﾄ
		case 0: // 紙あり
			st = Ex_portFlag[EXPORT_R_PNEND];
			Ex_portFlag[EXPORT_R_PEND]		= 0;
			Ex_portFlag[EXPORT_R_PNEND]		= 0;
			if( 1 == st ){											// ﾚｼｰﾄ紙切れ復旧
				dt = 0;
				queset( OPETCBNO, MID_STSCHG_R_PNEND, 1, &dt );		// Opeへﾒｰﾙ送信
// MH810105(S) MH364301 インボイス対応
				queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );		// Opeへﾒｰﾙ送信
// MH810105(E) MH364301 インボイス対応
			}
			break;
		case 1: // 紙切れ予告
			st = Ex_portFlag[EXPORT_R_PNEND];
			Ex_portFlag[EXPORT_R_PNEND]		= 1;
			Ex_portFlag[EXPORT_R_PEND]		= 0;
			if( 0 == st ){											// ﾚｼｰﾄ紙切れ発生
				dt = 1;
				queset( OPETCBNO, MID_STSCHG_R_PNEND, 1, &dt );		// Opeへﾒｰﾙ送信
// MH810105(S) MH364301 インボイス対応
				queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );		// Opeへﾒｰﾙ送信
// MH810105(E) MH364301 インボイス対応
			}
			break;
		case -1: // 紙切れ
			st = Ex_portFlag[EXPORT_R_PNEND];
			Ex_portFlag[EXPORT_R_PEND]		= 1;
			Ex_portFlag[EXPORT_R_PNEND]		= 1;
			if( 0 == st ){											// ﾚｼｰﾄ紙切れ発生
				dt = 1;
				queset( OPETCBNO, MID_STSCHG_R_PNEND, 1, &dt );		// Opeへﾒｰﾙ送信
// MH810105(S) MH364301 インボイス対応
				queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );		// Opeへﾒｰﾙ送信
// MH810105(E) MH364301 インボイス対応
			}
			break;
	}

	//--------------------------------------------------------------------------------------*/
	//	ｼﾞｬｰﾅﾙ紙切れﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	switch( paperchk2() ){	// ｼﾞｬｰﾅﾙ
		case 0: // 紙あり
			st = Ex_portFlag[EXPORT_J_PNEND];
			Ex_portFlag[EXPORT_J_PEND]		= 0;
			Ex_portFlag[EXPORT_J_PNEND]		= 0;
			if( 1 == st ){											// ｼﾞｬｰﾅﾙ紙切れ復旧
				dt = 0;
				queset( OPETCBNO, MID_STSCHG_J_PNEND, 1, &dt );		// Opeへﾒｰﾙ送信
// MH810105(S) MH364301 インボイス対応
				queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );		// Opeへﾒｰﾙ送信
// MH810105(E) MH364301 インボイス対応
			}
			break;
		case 1: // 紙切れ予告
			st = Ex_portFlag[EXPORT_J_PNEND];
			Ex_portFlag[EXPORT_J_PNEND]		= 1;
			Ex_portFlag[EXPORT_J_PEND]		= 0;
			if( 0 == st ){											// ｼﾞｬｰﾅﾙ紙切れ発生
				dt = 1;
				queset( OPETCBNO, MID_STSCHG_J_PNEND, 1, &dt );		// Opeへﾒｰﾙ送信
// MH810105(S) MH364301 インボイス対応
				queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );		// Opeへﾒｰﾙ送信
// MH810105(E) MH364301 インボイス対応
			}
			break;
		case -1: // 紙切れ
			st = Ex_portFlag[EXPORT_J_PNEND];
			Ex_portFlag[EXPORT_J_PEND]		= 1;
			Ex_portFlag[EXPORT_J_PNEND]		= 1;
			if( 0 == st ){											// ｼﾞｬｰﾅﾙ紙切れ発生
				dt = 1;
				queset( OPETCBNO, MID_STSCHG_J_PNEND, 1, &dt );		// Opeへﾒｰﾙ送信
// MH810105(S) MH364301 インボイス対応
				queset( OPETCBNO, OPE_OPNCLS_EVT, 0, NULL );		// Opeへﾒｰﾙ送信
// MH810105(E) MH364301 インボイス対応
			}
			break;
	}

	//--------------------------------------------------------------------------------------*/
	//	ﾚｼｰﾄ又はｼﾞｬｰﾅﾙ紙切れﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	if( !Ex_portFlag[EXPORT_J_PNEND] && !Ex_portFlag[EXPORT_R_PNEND] ){
		Ex_portFlag[EXPORT_JR_PNEND] = 0;
	}
	if( !Ex_portFlag[EXPORT_J_PEND] && !Ex_portFlag[EXPORT_R_PEND] ){
		Ex_portFlag[EXPORT_JR_PEND] = 0;
	}
	if( Ex_portFlag[EXPORT_J_PNEND] || Ex_portFlag[EXPORT_R_PNEND] ){
		Ex_portFlag[EXPORT_JR_PNEND] = 1;
	}
	if( Ex_portFlag[EXPORT_J_PEND] || Ex_portFlag[EXPORT_R_PEND] ){
		Ex_portFlag[EXPORT_JR_PEND] = 1;
	}

	//--------------------------------------------------------------------------------------*/
	//	ｺｲﾝ金庫満杯ﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	switch( cinful() ){
		case 0: // 満杯でない
			Ex_portFlag[EXPORT_COINNFUL] = 0;
			Ex_portFlag[EXPORT_COINFUL] = 0;
			break;
		case 1: // ほぼ満杯
			Ex_portFlag[EXPORT_COINNFUL] = 1;
			Ex_portFlag[EXPORT_COINFUL] = 0;
			break;
		case -1: // 満杯
			Ex_portFlag[EXPORT_COINNFUL] = 1;
			Ex_portFlag[EXPORT_COINFUL] = 1;
			break;
	}

	//--------------------------------------------------------------------------------------*/
	//	紙幣金庫満杯ﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	switch( notful() ){
		case 0: // 満杯でない
			Ex_portFlag[EXPORT_NOTENFUL] = 0;
			Ex_portFlag[EXPORT_NOTEFUL] = 0;
			break;
		case 1: // ほぼ満杯
			Ex_portFlag[EXPORT_NOTENFUL] = 1;
			Ex_portFlag[EXPORT_NOTEFUL] = 0;
			break;
		case -1: // 満杯
			Ex_portFlag[EXPORT_NOTENFUL] = 1;
			Ex_portFlag[EXPORT_NOTEFUL] = 1;
			break;
	}

	//--------------------------------------------------------------------------------------*/
	//	紙幣金庫またはｺｲﾝ金庫満杯ﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	if( !Ex_portFlag[EXPORT_COINNFUL] && !Ex_portFlag[EXPORT_NOTENFUL] ){
		Ex_portFlag[EXPORT_SAFENFUL] = 0;
	}
	if( !Ex_portFlag[EXPORT_COINFUL] && !Ex_portFlag[EXPORT_NOTEFUL] ){
		Ex_portFlag[EXPORT_SAFEFUL] = 0;
	}
	if( Ex_portFlag[EXPORT_COINNFUL] || Ex_portFlag[EXPORT_NOTENFUL] ){
		Ex_portFlag[EXPORT_SAFENFUL] = 1;
	}
	if( Ex_portFlag[EXPORT_COINFUL] || Ex_portFlag[EXPORT_NOTEFUL] ){
		Ex_portFlag[EXPORT_SAFEFUL] = 1;
	}

	//--------------------------------------------------------------------------------------*/
	//	ｺｲﾝ釣銭切れﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	switch( turick() ){
		case 0: // 釣りあり
			st = Ex_portFlag[EXPORT_CHGNEND];
			Ex_portFlag[EXPORT_CHGEND] = 0;
			Ex_portFlag[EXPORT_CHGNEND] = 0;
			if( 1 == st ){											// 釣銭切れ復旧
				dt = 0;
				queset( OPETCBNO, MID_STSCHG_CHGEND, 1, &dt );		// Opeへﾒｰﾙ送信
			}
			break;
		case 1: // 釣銭切れ予告
			st = Ex_portFlag[EXPORT_CHGNEND];
			Ex_portFlag[EXPORT_CHGNEND] = 1;
			Ex_portFlag[EXPORT_CHGEND] = 0;
			if( 0 == st ){											// 釣銭切れ発生
				dt = 1;
				queset( OPETCBNO, MID_STSCHG_CHGEND, 1, &dt );		// Opeへﾒｰﾙ送信
			}
			break;
		case -1: // 釣銭切れ
			st = Ex_portFlag[EXPORT_CHGEND];
			Ex_portFlag[EXPORT_CHGEND] = 1;
			Ex_portFlag[EXPORT_CHGNEND] = 1;
			if( 0 == st ){											// 釣銭切れ発生
				dt = 1;
				queset( OPETCBNO, MID_STSCHG_CHGEND, 1, &dt );		// Opeへﾒｰﾙ送信
			}
			break;
		default:
			break;
	}

	//--------------------------------------------------------------------------------------*/
	//	営業／休業ﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	if( !CLOSE_stat ){	// 営業
		Ex_portFlag[EXPORT_CLOSE] = 0;
	}else{				// 休業
		Ex_portFlag[EXPORT_CLOSE] = 1;
	}

	//--------------------------------------------------------------------------------------*/
	//	ﾗﾍﾞﾙﾌﾟﾘﾝﾀ紙切れ予告ﾁｪｯｸ
	//--------------------------------------------------------------------------------------*/
	switch( LabelPaperchk() ){
		case 0:		// 解除
			Ex_portFlag[EXPORT_LPR_PEND]  = 0;						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ
			Ex_portFlag[EXPORT_LPR_PNEND] = 0;						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ予告
			break;

		case 1:		// 予告
			Ex_portFlag[EXPORT_LPR_PEND]  = 0;						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ
			Ex_portFlag[EXPORT_LPR_PNEND] = 1;						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ予告
			break;

		case -1:	// 発生
			Ex_portFlag[EXPORT_LPR_PEND]  = 1;						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ
			Ex_portFlag[EXPORT_LPR_PNEND] = 1;						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ予告
			break;
	}

	//--------------------------------------------------------------------------------------*/
	//	状態に変化があれば信号出力
	//--------------------------------------------------------------------------------------*/
	for( i = 0; i < EXPORTSIGNALNUM; i++ ) {
		dt = Ex_portFlag[i];
		if( Ex_OutFlag[i] != Ex_portFlag[i] ) {						// 現在の出力状態と異なる?(Y)
			ExOutSignal( (uchar)i, (uchar)dt);
			Ex_OutFlag[i] = dt;										// 出力中保持
		}
	}
}

/*[]----------------------------------------------------------------------------------------------[]*/
/*| 外部信号出力																				   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| MODULE NAME	: Ex_outport( void );															   |*/
/*| PARAMETER	: void																			   |*/
/*| RETURN VALUE: void																			   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| Author		: T.Hashimoto																	   |*/
/*| Date		: 2005-06-15																	   |*/
/*[]------------------------------------------------------------- Copyright(C) 2001 AMANO Corp.---[]*/
void	ExOutSignal( uchar kind, uchar onoff )
{
	switch( kind ){
		case EXPORT_J_PEND:
			OutSignalCtrl( SIG_J_PEND, onoff );							// ｼﾞｬｰﾅﾙ紙切れ
			break;
		case EXPORT_J_PNEND:
			OutSignalCtrl( SIG_J_PNEND, onoff );						// ｼﾞｬｰﾅﾙ紙切れ予告
			break;
		case EXPORT_R_PEND:
			OutSignalCtrl( SIG_R_PEND, onoff );							// ﾚｼｰﾄ紙切れ
			break;
		case EXPORT_R_PNEND:
			OutSignalCtrl( SIG_R_PNEND, onoff );						// ﾚｼｰﾄ紙切れ予告
			break;
		case EXPORT_JR_PEND:
			OutSignalCtrl( SIG_JR_PEND, onoff );						// ｼﾞｬｰﾅﾙ又はﾚｼｰﾄ紙切れ
			break;
		case EXPORT_JR_PNEND:
			OutSignalCtrl( SIG_JR_PNEND, onoff );						// ｼﾞｬｰﾅﾙ又はﾚｼｰﾄ紙切れ予告
			break;
		case EXPORT_TROUBLE:
			OutSignalCtrl( SIG_TROUBLE, onoff );						// ﾄﾗﾌﾞﾙ
			break;
		case EXPORT_CARFUL1:
			OutSignalCtrl( SIG_CARFUL1, onoff );						// 満車1
// MH810100(S) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
//			if( onoff == 1 ){											// on
//				wmonlg( OPMON_CAR1_FULL, 0, 0 );						// ﾓﾆﾀ登録(満車1)
//			}
// MH810100(E) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
			break;
		case EXPORT_CARFUL2:
			OutSignalCtrl( SIG_CARFUL2, onoff );						// 満車2
// MH810100(S) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
//			if( onoff == 1 ){											// on
//				wmonlg( OPMON_CAR2_FULL, 0, 0 );						// ﾓﾆﾀ登録(満車1)
//			}
// MH810100(E) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
			break;
		case EXPORT_CARFUL3:
			OutSignalCtrl( SIG_CARFUL3, onoff );						// 満車3
// MH810100(S) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
//			if( onoff == 1 ){											// on
//				wmonlg( OPMON_CAR3_FULL, 0, 0 );						// ﾓﾆﾀ登録(満車1)
//			}
// MH810100(E) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
			break;
		case EXPORT_CAREMPTY1:
			OutSignalCtrl( SIG_CAREMPTY1, onoff );						// 空車1
// MH810100(S) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
//			if( onoff == 1 ){											// on
//				wmonlg( OPMON_CAR1_UNFULL, 0, 0 );						// ﾓﾆﾀ登録(空車1)
//			}
// MH810100(E) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
			break;
		case EXPORT_CAREMPTY2:
			OutSignalCtrl( SIG_CAREMPTY2, onoff );						// 空車2
// MH810100(S) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
//			if( onoff == 1 ){											// on
//				wmonlg( OPMON_CAR2_UNFULL, 0, 0 );						// ﾓﾆﾀ登録(空車2)
//			}
// MH810100(E) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
			break;
		case EXPORT_CAREMPTY3:
			OutSignalCtrl( SIG_CAREMPTY3, onoff );						// 空車3
// MH810100(S) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
//			if( onoff == 1 ){											// on
//				wmonlg( OPMON_CAR3_UNFULL, 0, 0 );						// ﾓﾆﾀ登録(空車3)
//			}
// MH810100(E) K.Onodera  2019/12/23 車番チケットレス(フラップ式->ゲート式変更に伴う処理見直し)
			break;
		case EXPORT_CLOSE:
			OutSignalCtrl( SIG_CLOSE, onoff );							// 休業中
			if( onoff == 0 ){											// off
				wmonlg( OPMON_OPEN, 0, 0 );								// ﾓﾆﾀ登録(営業中)
			}else if( onoff == 1 ){										// on
				wmonlg( OPMON_CLOSW, 0, 0 );							// ﾓﾆﾀ登録(休業中)
			}
			break;
		case EXPORT_COINNFUL:
			OutSignalCtrl( SIG_COINNFUL, onoff );						// ｺｲﾝ満杯予告信号ON
			break;
		case EXPORT_NOTENFUL:
			OutSignalCtrl( SIG_NOTENFUL, onoff );						// 紙幣金庫満杯予告
			break;
		case EXPORT_SAFENFUL:
			OutSignalCtrl( SIG_SAFENFUL, onoff );						// ｺｲﾝ金庫又は紙幣金庫満杯予告信号ON
			break;
		case EXPORT_COINFUL:
			OutSignalCtrl( SIG_COINFUL, onoff );						// ｺｲﾝ満杯信号ON
			break;
		case EXPORT_NOTEFUL:
			OutSignalCtrl( SIG_NOTEFUL, onoff );						// 紙幣金庫満杯
			break;
		case EXPORT_SAFEFUL:
			OutSignalCtrl( SIG_SAFEFUL, onoff );						// ｺｲﾝ金庫又は紙幣金庫満杯
			break;
		case EXPORT_CHGEND:
			OutSignalCtrl( SIG_CHGEND, onoff );							// 釣銭切れ
			break;
		case EXPORT_CHGNEND:
			OutSignalCtrl( SIG_CHGNEND, onoff );						// 釣銭切れ予告
			break;
		case EXPORT_LPR_PEND:
			OutSignalCtrl( SIG_LPR_PEND, onoff );						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ
			break;
		case EXPORT_LPR_PNEND:
			OutSignalCtrl( SIG_LPR_PNEND, onoff );						// ﾗﾍﾞﾙ紙切れ又はﾘﾎﾞﾝ切れ予告
			break;
		case EXPORT_SECURITY:
			OutSignalCtrl( SIG_SECURITY, onoff );						// 防犯センサー
			break;
	}
}


/*[]----------------------------------------------------------------------------------------------[]*/
/*| Reciept Printer Paper Check																	   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| MODULE NAME	: paperchk( void )																   |*/
/*| PARAMETER	: void																			   |*/
/*| RETURN VALUE: ret	: 0=あり 1=紙切れ予告 -1:紙なし											   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| Author		: T.Hashimoto																	   |*/
/*| Date		: 2005-06-16																	   |*/
/*[]------------------------------------------------------------- Copyright(C) 2001 AMANO Corp.---[]*/
short paperchk( void )
{
	short ret = 0;

	if( ALM_CHK[ALMMDL_SUB][ALARM_RPAPEREND] != 0 ){
		ret = -1;
	}else{
		if( ALM_CHK[ALMMDL_SUB][ALARM_RPAPERNEAREND] != 0 ){
			ret = 1;
		}
	}
	return( ret );
}

/*[]----------------------------------------------------------------------------------------------[]*/
/*| ｼﾞｬｰﾅﾙ Printer Paper Check																	   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| MODULE NAME	: paperchk2( void )																   |*/
/*| PARAMETER	: void																			   |*/
/*| RETURN VALUE: ret	: 0=あり 1=紙切れ予告 -1:紙なし											   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| Author		: T.Hashimoto																	   |*/
/*| Date		: 2005-08-10																	   |*/
/*[]------------------------------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
short paperchk2( void )
{
	short ret = 0;

	if( ALM_CHK[ALMMDL_SUB][ALARM_JPAPEREND] != 0 ){
		ret = -1;
	}else{
		if( ALM_CHK[ALMMDL_SUB][ALARM_JPAPERNEAREND] != 0 ){
			ret = 1;
		}
	}
// MH810104 GG119201(S) 電子ジャーナル対応
	if( ALM_CHK[ALMMDL_SUB][ALARM_SD_END] != 0 ){
		ret = -1;
	}else{
		if( ALM_CHK[ALMMDL_SUB][ALARM_SD_NEAR_END] != 0 ){
			ret = 1;
		}
	}
// MH810104 GG119201(E) 電子ジャーナル対応
// MH810105(S) MH364301 インボイス対応
	if (IsErrorOccuerd(ERRMDL_EJA, ERR_EJA_SD_UNAVAILABLE)) {
		// SD使用不可は紙切れ扱いとする
		ret = -1;
	}
// MH810105(E) MH364301 インボイス対応
	return( ret );
}

/*[]----------------------------------------------------------------------------------------------[]*/
/*| Car Full Check																				   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
/*| MODULE NAME	: fulchk( void )																   |*/
/*| PARAMETER	: void																			   |*/
/*[]----------------------------------------------------------------------------------------------[]*/
void fulchk( void )
{
	long	mode[3];							// 強制満空車ﾓｰﾄﾞ
	long	car_cnt[3];							// 現在台数
	long	ful_cnt[3];							// 満車台数
	long	kai_cnt[3];							// 満車解除台数
	uchar	parm[2];							//[0]：満車信号　[1]：空車信号
	ushort	i;
	long	areanum;

	// 比較データの作成
	for (i = 0; i < 3; i++) {
		// 無効値
		mode[i] = 0;
		car_cnt[i] = -1;
		ful_cnt[i] = -1;
		kai_cnt[i] = -1;
		switch (prm_get(COM_PRM,S_SYS,39,1,2)) {
		case 2:
			// 比較台数ｾｯﾄ
			areanum = prm_get(COM_PRM,S_SYS,39,1,1);	//0,3,4のいずれか
			if (areanum == 0) {
				// 用途別駐車台数が0ならば先頭ｴﾘｱのみに台数ｴﾘｱ0の値をｾｯﾄ
				if (i == 0) {
					car_cnt[i] = PPrmSS[S_P02][(i*4)+2];	// 「現在台数」			ﾃﾞｰﾀ取得
					ful_cnt[i] = PPrmSS[S_P02][(i*4)+3];	// 「満車台数」			ﾃﾞｰﾀ取得
					kai_cnt[i] = PPrmSS[S_P02][(i*4)+4];	// 「満車解除台数」		ﾃﾞｰﾀ取得
				}
			} else {
				if ((i+1) < areanum) {
					car_cnt[i] = PPrmSS[S_P02][((i+1)*4)+2];	// 「現在台数」			ﾃﾞｰﾀ取得
					ful_cnt[i] = PPrmSS[S_P02][((i+1)*4)+3];	// 「満車台数」			ﾃﾞｰﾀ取得
					kai_cnt[i] = PPrmSS[S_P02][((i+1)*4)+4];	// 「満車解除台数」		ﾃﾞｰﾀ取得
				}
			}
			// そのまま 強制満空車ﾓｰﾄﾞｾｯﾄ へ
		case 1:
			areanum = prm_get(COM_PRM,S_SYS,39,1,1);	//0,3,4のいずれか
			// 強制満空車ﾓｰﾄﾞｾｯﾄ
			if (areanum == 0) {
				// 用途別駐車台数が0ならば先頭ｴﾘｱのみに台数ｴﾘｱ0の値をｾｯﾄ
				if (i == 0) {
					mode[i] = PPrmSS[S_P02][(i*4)+1];
				}
			} else {
				if ((i+1) < areanum) {
					mode[i] = PPrmSS[S_P02][((i+1)*4)+1];
				}
			}
			break;
		case 0:
			// 全て無効値
		default:
			break;
		}
	}

	// 満空車判別
	for (i = 0; i < 3; i++) {

		if (car_cnt[i] != -1) {
			if (car_cnt[i] >= ful_cnt[i]) {				// 現在台数≧満車台数？
				CARFULL_stat[i] = 1;
				if (!car_cnt[i]) {						// 現在台数=0は満車状態にしない
					CARFULL_stat[i] = 0;
				}
			} else if (car_cnt[i] <= kai_cnt[i]) {		// 現在台数＜満車解除台数？
				CARFULL_stat[i] = 0;
			}
		} else {
			CARFULL_stat[i] = 0xff;		//無効値
		}

		if(i==0){			// 満空車１
			parm[0] = EXPORT_CARFUL1;		// 満車1信号位置設定
			parm[1] = EXPORT_CAREMPTY1;		// 空車1信号位置設定
		}else if(i==1){		// 満空車２
			parm[0] = EXPORT_CARFUL2;		// 満車2信号位置設定
			parm[1] = EXPORT_CAREMPTY2;		// 空車2信号位置設定
		}else{				// 満空車３
			parm[0] = EXPORT_CARFUL3;		// 満車3信号位置設定
			parm[1] = EXPORT_CAREMPTY3;		// 空車3信号位置設定
		}

		switch (mode[i]) {							// 強制満空車ﾓｰﾄﾞ？
		case	1:							// 強制満車
			Ex_portFlag[parm[0]] = 1;		// 満車信号ON
			Ex_portFlag[parm[1]] = 0;		// 空車信号OFF
			s_FullFactor[i] = FORCE_FULL;
			break;
		case	2:							// 強制空車
			Ex_portFlag[parm[0]] = 0;		// 満車信号OFF
			Ex_portFlag[parm[1]] = 1;		// 空車信号ON
			s_FullFactor[i] = FORCE_VACANCY;
			break;
		default:							// 自動
			switch (FLAGPT.car_full[i+1]) {
			case 1:		//NT-NET満車ﾓｰﾄﾞ
				Ex_portFlag[parm[0]] = 1;	// 満車信号ON
				Ex_portFlag[parm[1]] = 0;	// 空車信号OFF
				s_FullFactor[i] = NTNET_FULL;
				break;
			case 2:		//NT-NET空車ﾓｰﾄﾞ
				Ex_portFlag[parm[0]] = 0;	// 満車信号OFF
				Ex_portFlag[parm[1]] = 1;	// 空車信号ON
				s_FullFactor[i] = NTNET_VACANCY;
				break;
			default:
				if (CARFULL_stat[i] == 1) {		// 満車状態維持
					Ex_portFlag[parm[0]] = 1;	// 満車信号ON
					Ex_portFlag[parm[1]] = 0;	// 空車信号OFF
					s_FullFactor[i] = AUTO_FULL;
				} else if (CARFULL_stat[i] == 0) {
					Ex_portFlag[parm[0]] = 0;	// 満車信号OFF
					Ex_portFlag[parm[1]] = 1;	// 空車信号ON
					s_FullFactor[i] = AUTO_VACANCY;
				} else {
					// 満空車管理台数が無効値なら 空車(通信) とする
					Ex_portFlag[parm[0]] = 0;	// 満車信号OFF
					Ex_portFlag[parm[1]] = 1;	// 空車信号ON
					s_FullFactor[i] = NTNET_VACANCY;
				}
				break;
			}
// MH322914 (s) kasiyama 2016/07/08 [break]を入れる(共通改善No.896)(MH341106)
			break;
// MH322914 (e) kasiyama 2016/07/08 [break]を入れる(共通改善No.896)(MH341106)
		}
	}
}

/*[]----------------------------------------------------------------------[]*/
/*| 満車/空車 理由取得 */
/*[]----------------------------------------------------------------------[]*/
char	getFullFactor(unsigned char chk_no)
{
	return s_FullFactor[chk_no];
}

/*[]----------------------------------------------------------------------[]*/
/*| 釣り銭ﾁｪｯｸ                                                             |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : turick( void );                                         |*/
/*| PARAMETER    : void                                                    |*/
/*| RETURN VALUE : ret : 0=釣有り  -1=釣切れ  1=釣切れ予告                 |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(NT4500EXより流用)                                  |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
short	turick( void )
{
	short	ret;
	int		i;
	long	genmai[4];

	if( OPECTL.Ope_mod == 2 ) return( -2 );

	ret = 0;

	if( cnm_ctrl_info.BIT.r_dat09_rcv_wait ){		// 一括要求後の払出可能枚数データ受信待ち
		cnm_ctrl_info.BIT.r_dat09_rcv_wait = 0;		// フラグOFF 次回のチェックはデータを受信してなくても行う
		return ret;								// 釣銭切れチェックは行わない
	}
	for( ; ; ){
		if( prm_get( COM_PRM,S_KAN,53,1,1 ) ){						// 釣切れ対象とする?
			if( CN_RDAT.r_dat09[0] == 0 ){							// 10円ﾅｼ
				ret = -1;
				alm_chk( ALMMDL_SUB, ALARM_10COIN_EMPTY, 1 );		// ｱﾗｰﾑﾛｸﾞ登録
			}else{
				alm_chk( ALMMDL_SUB, ALARM_10COIN_EMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ登録
			}
		}
		else{
			alm_chk( ALMMDL_SUB, ALARM_10COIN_EMPTY, 0 );			// ｱﾗｰﾑﾛｸﾞ解除
		}

		if( prm_get( COM_PRM,S_KAN,53,1,2 ) ){						// 釣切れ対象とする?
			if( CN_RDAT.r_dat09[1] == 0 ){							// 50円ﾅｼ
				ret = -1;
				alm_chk( ALMMDL_SUB, ALARM_50COIN_EMPTY, 1 );		// ｱﾗｰﾑﾛｸﾞ登録
			}else{
				alm_chk( ALMMDL_SUB, ALARM_50COIN_EMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ登録
			}
		}
		else{
			alm_chk( ALMMDL_SUB, ALARM_50COIN_EMPTY, 0 );			// ｱﾗｰﾑﾛｸﾞ解除
		}

		if( prm_get( COM_PRM,S_KAN,53,1,3 ) ){						// 釣切れ対象とする?
			if( CN_RDAT.r_dat09[2] == 0 ){							// 100円ﾅｼ
				ret = -1;
				alm_chk( ALMMDL_SUB, ALARM_100COIN_EMPTY, 1 );		// ｱﾗｰﾑﾛｸﾞ登録
			}else{
				alm_chk( ALMMDL_SUB, ALARM_100COIN_EMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ登録
			}
		}
		else{
			alm_chk( ALMMDL_SUB, ALARM_100COIN_EMPTY, 0 );			// ｱﾗｰﾑﾛｸﾞ解除
		}

		if( prm_get( COM_PRM,S_KAN,53,1,4 ) ){						// 釣切れ対象とする?
			if( CN_RDAT.r_dat09[3] == 0 ){							// 500円ﾅｼ
				ret = -1;
				alm_chk( ALMMDL_SUB, ALARM_500COIN_EMPTY, 1 );		// ｱﾗｰﾑﾛｸﾞ登録
			}else{
				alm_chk( ALMMDL_SUB, ALARM_500COIN_EMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ登録
			}
		}
		else{
			alm_chk( ALMMDL_SUB, ALARM_500COIN_EMPTY, 0 );			// ｱﾗｰﾑﾛｸﾞ解除
		}


		if( CPrmSS[S_KAN][1] )
		{	// 金銭管理ﾓｰﾄﾞである
			for( i = 0; i < 4; i++ ){
				genmai[i] = turi_kan.turi_dat[i].gen_mai;
				genmai[i] += turi_kan.turi_dat[i].ygen_mai;
			}

			if( prm_get( COM_PRM,S_KAN,56,1,1 ) ){					// 10円釣切れ予告対象とする?
				if( CPrmSS[S_KAN][4] >= genmai[0]){
					if(0 == ret) ret = 1;
					alm_chk( ALMMDL_SUB, ALARM_10COIN_NEMPTY, 1 );	// ｱﾗｰﾑﾛｸﾞ登録
				}else{
					alm_chk( ALMMDL_SUB, ALARM_10COIN_NEMPTY, 0 );	// ｱﾗｰﾑﾛｸﾞ登録
				}
			}
			else{
				alm_chk( ALMMDL_SUB, ALARM_10COIN_NEMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ解除
			}

			if( prm_get( COM_PRM,S_KAN,56,1,2 ) ){					// 50円釣切れ予告対象とする?
				if( CPrmSS[S_KAN][10] >= genmai[1]){
					if(0 == ret) ret = 1;
					alm_chk( ALMMDL_SUB, ALARM_50COIN_NEMPTY, 1 );	// ｱﾗｰﾑﾛｸﾞ登録
				}else{
					alm_chk( ALMMDL_SUB, ALARM_50COIN_NEMPTY, 0 );	// ｱﾗｰﾑﾛｸﾞ登録
				}
			}
			else{
				alm_chk( ALMMDL_SUB, ALARM_50COIN_NEMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ解除
			}

			if( prm_get( COM_PRM,S_KAN,56,1,3 ) ){					// 100円釣切れ予告対象とする?
				if( CPrmSS[S_KAN][16] >= genmai[2]){
					if(0 == ret) ret = 1;
					alm_chk( ALMMDL_SUB, ALARM_100COIN_NEMPTY, 1 );	// ｱﾗｰﾑﾛｸﾞ登録
				}else{
					alm_chk( ALMMDL_SUB, ALARM_100COIN_NEMPTY, 0 );	// ｱﾗｰﾑﾛｸﾞ登録
				}
			}
			else{
				alm_chk( ALMMDL_SUB, ALARM_100COIN_NEMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ解除
			}

			if( prm_get( COM_PRM,S_KAN,56,1,4 ) ){					// 500円釣切れ予告対象とする?
				if( CPrmSS[S_KAN][22] >= genmai[3]){
					if(0 == ret) ret = 1;
					alm_chk( ALMMDL_SUB, ALARM_500COIN_NEMPTY, 1 );	// ｱﾗｰﾑﾛｸﾞ登録
				}else{
					alm_chk( ALMMDL_SUB, ALARM_500COIN_NEMPTY, 0 );	// ｱﾗｰﾑﾛｸﾞ登録
				}
			}
			else{
				alm_chk( ALMMDL_SUB, ALARM_500COIN_NEMPTY, 0 );		// ｱﾗｰﾑﾛｸﾞ解除
			}
		}
		break;
	}
	return( ret );
}

/*[]----------------------------------------------------------------------[]*/
/*| ｺｲﾝ金庫満杯ﾁｪｯｸ                                                        |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : cinful( void );                                         |*/
/*| PARAMETER    : void                                                    |*/
/*| RETURN VALUE : ret : 0=OK 1=ほぼ満杯 -1=満杯                           |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(NT4500EXより流用)                                  |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
short	cinful( void )
{
	long	cincnt;

	cincnt = (long)(SFV_DAT.safe_dt[0]) * POINT_10;
	cincnt += (long)(SFV_DAT.safe_dt[1]) * POINT_50;
	cincnt += (long)(SFV_DAT.safe_dt[2]) * POINT_100;
	cincnt += (long)(SFV_DAT.safe_dt[3]) * POINT_500;

	if( cincnt >= COIN_FULL ){
		alm_chk( ALMMDL_SUB, ALARM_COINSAFENFULL, 1 );				// ﾆｱﾌﾙｱﾗｰﾑﾛｸﾞ登録
		alm_chk( ALMMDL_SUB, ALARM_COINSAFEFULL, 1 );				// ｱﾗｰﾑﾛｸﾞ登録
		return( -1 );												// 満杯
	}
	if( cincnt >= COIN_NEAR_FULL ){
		alm_chk( ALMMDL_SUB, ALARM_COINSAFENFULL, 1 );				// ｱﾗｰﾑﾛｸﾞ登録
		return( 1 );												// ほぼ満杯
	}
	alm_chk( ALMMDL_SUB, ALARM_COINSAFEFULL, 0 );					// ｱﾗｰﾑﾛｸﾞ登録
	alm_chk( ALMMDL_SUB, ALARM_COINSAFENFULL, 0 );					// ｱﾗｰﾑﾛｸﾞ登録
	return( 0 );													// OK
}

/*[]----------------------------------------------------------------------[]*/
/*| 紙幣金庫満杯ﾁｪｯｸ                                                       |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : notful( void );                                         |*/
/*| PARAMETER    : void                                                    |*/
/*| RETURN VALUE : ret : 0=OK -1=満杯 1=ほぼ満杯                           |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(NT4500EXより流用)                                  |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
short	notful( void )
{
	short	cnt;

	if( NT_RDAT.r_dat1c[0] & 0x80 ){
		alm_chk( ALMMDL_SUB, ALARM_NOTESAFENFULL, 1 ); 				// ﾆｱﾌﾙｱﾗｰﾑﾛｸﾞ登録
		alm_chk( ALMMDL_SUB, ALARM_NOTESAFEFULL, 1 ); 				// ｱﾗｰﾑﾛｸﾞ登録
		return( -1 );												// 満杯
	}
	cnt = SFV_DAT.nt_safe_dt;
	if( cnt >= NOTE_NEAR_FULL ){
		alm_chk( ALMMDL_SUB, ALARM_NOTESAFENFULL, 1 ); 				// ｱﾗｰﾑﾛｸﾞ登録
		return( 1 );												// 満杯予告
	}
	alm_chk( ALMMDL_SUB, ALARM_NOTESAFEFULL, 0 );					// ｱﾗｰﾑﾛｸﾞ登録
	alm_chk( ALMMDL_SUB, ALARM_NOTESAFENFULL, 0 )	; 				// ｱﾗｰﾑﾛｸﾞ登録
	return( 0 );													// OK
}
/*[]----------------------------------------------------------------------[]*/
/*| Reader Status Check & Error Loging                                     |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : err_mod_chk                                             |*/
/*| PARAMETER    : char  *new : New Status                                 |*/
/*|                char  *old : Old Status                                 |*/
/*|                short no   : 0=Reader  1=Journal                        |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(TF4800N,NT4500EXより流用)                          |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
const unsigned char	ERR_SND_ERR[4][8] = {
	/* BIT0 -> BIT7 */
	{  0,  0,  0,  0,  0,  0,  0,  0 },								// EOT Status1
	{ ERR_RED_LOCSENSOR1,											// EOT Status2
	  ERR_RED_LOCSENSOR2,
	  ERR_RED_LOCSENSOR3,
	  ERR_RED_LOCSENSOR4,
	  ERR_RED_LOCSENSOR5,
	  ERR_RED_LOCSENSOR6,
	  ERR_RED_LOCSENSOR7,
	  ERR_RED_PRNLOCSENSOR },
	{ ERR_RED_HPSENSOR1,											// EOT Status3
	  ERR_RED_HPSENSOR2,
	  0,  0,  0,  0,  0,  0 },
	{ ERR_RED_STACK_R,												// EOT Status4
	  ERR_RED_STACK_P,
	  0,  0,  0,  0,  0,
	  ERR_RED_MEMORY }
};

void	err_mod_chk( unsigned char *newdt, unsigned char *old, short no )
{
	unsigned char	i;
	unsigned char	j;
	char	set;
	unsigned char	errlg;
	unsigned char	bit;

	if( no == 0 ){													// Reader ?(Y)
		set = (char)prm_get( COM_PRM,S_PAY,21,1,3 );

		for( i = 0; i < 4; i++ ){									// 4Byte
			if( newdt[i] != old[i] ){								// 変化ｱﾘ?(Y)
				bit = 1;
				for( j = 0; j < 8 ; j++, bit <<=1 ){ 				// BIT check
					if(( newdt[i] & bit )!=( old[i] & bit )){

						errlg = ERR_SND_ERR[i][j];

						/****************************************************************/
						/* 磁気ﾘｰﾀﾞの問題吸収											*/
						/* ﾌﾟﾘﾝﾀなし設定の場合に、ﾌﾟﾘﾝﾀ関連のｴﾗｰを返す為、発生を無視する*/
						/****************************************************************/

						if(( set == 1 )||( set == 3 )){				// 1方向ﾘｰﾀﾞ
							if(( errlg == ERR_RED_HPSENSOR1 )||
								( errlg == ERR_RED_HPSENSOR2 )){	// 1方向の為HPｾﾝｻ1無効
								errlg = 0;							// 1方向の為HPｾﾝｻ2無効
							}
						}
						if(( set == 3 )||( set == 4 )){				// ﾌﾟﾘﾝﾀなし
							if(( errlg == ERR_RED_STACK_P )||
								( errlg == ERR_RED_PRNLOCSENSOR )){	// ﾌﾟﾘﾝﾀ詰まり無効
								errlg = 0;							// ﾌﾟﾘﾝﾀｾﾝｻ状態無効
							}
						}
						if( errlg != 0 ){							// ｴﾗｰ変化有り?(Y)
							if( newdt[i] & bit ){
								err_chk( ERRMDL_READER, (char)errlg, 1, 0, 0 );// 発生
							}else{
								err_chk( ERRMDL_READER,(char)errlg, 0, 0, 0 );	// 解除
							}
						}
						if(	( errlg == ERR_RED_STACK_P ) ||			// ﾌﾟﾘﾝﾀ詰まり
							( errlg == ERR_RED_STACK_R ))			// ﾘｰﾀﾞｰ詰まり
						{
							if (OPECTL.Mnt_mod == 0 &&
								(OPECTL.Ope_mod == 2 || OPECTL.Ope_mod == 3)){	// 精算中
								if( ERR_RED_STACK_P == errlg ){
									if( newdt[i] & bit ){
										IoLog_write(IOLOG_EVNT_ERR_REDSTACK_P_Ge, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 磁気リーダ：プリンター内カード詰まり 発生
									} else {
										IoLog_write(IOLOG_EVNT_ERR_REDSTACK_P_Re, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 磁気リーダ：プリンター内カード詰まり 解除
									}
								} else if( ERR_RED_STACK_R == errlg ){
									if( newdt[i] & bit ){
										IoLog_write(IOLOG_EVNT_ERR_REDSTACK_R_Ge, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 磁気リーダ：リーダ内カード詰まり 発生
									} else {
										IoLog_write(IOLOG_EVNT_ERR_REDSTACK_R_Re, (ushort)LockInfo[OPECTL.Pr_LokNo - 1].posi, 0, 0);	// 磁気リーダ：リーダ内カード詰まり 解除
									}
								}
							}
							StackCardEject(5);						// クレジットカード詰まり処理
						}
					}
			    }
			}
		}
	}
}

/*[]----------------------------------------------------------------------[]*/
/*| ﾗﾍﾞﾙﾌﾟﾘﾝﾀ紙切れ予告ﾁｪｯｸ                                                |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : LabelPaperchk( void );                                  |*/
/*| PARAMETER    : void                                                    |*/
/*| RETURN VALUE : ret : 0=OK 1=ﾗﾍﾞﾙ切れ予告                               |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara                                                    |*/
/*| Date         : 2006-04-20                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2006 AMANO Corp.---[]*/
short	LabelPaperchk( void )
{

	char	ck_f;

	ck_f = 0;
	if( ( prm_get(COM_PRM,S_PAY,25,2,1) != 0 )&&( CPrmSS[S_KOU][1] ) ){	// 定期更新あり&ﾗﾍﾞﾙﾌﾟﾘﾝﾀあり
		if( prm_get( COM_PRM,S_KOU,25,2,1 ) >= PPrmSS[S_P01][10] ){
			// ﾗﾍﾞﾙ現在枚数がﾆｱｴﾝﾄﾞ枚数以下だったらﾗﾍﾞﾙ切れ予告とする
			ck_f = 1;
		}
	}
	alm_chk( ALMMDL_SUB, ALARM_LBPAPERNEAREND, ck_f ); 				// ｱﾗｰﾑﾛｸﾞ登録

	if(	ALM_CHK[ALMMDL_SUB][ALARM_LBPAPEREND] ||					// ﾗﾍﾞﾙ紙切れ
		ALM_CHK[ALMMDL_SUB][ALARM_LBRIBBONEND] ){					// ﾗﾍﾞﾙﾘﾎﾞﾝ切れ
		return( -1 );	// 発生
	}
	if(	ALM_CHK[ALMMDL_SUB][ALARM_LBPAPERNEAREND] ||				// ﾗﾍﾞﾙ紙切れ予告
		ALM_CHK[ALMMDL_SUB][ALARM_LBRIBBONNEAREND] ){				// ﾗﾍﾞﾙﾘﾎﾞﾝ切れ予告

		return( 1 );	// 予告
	}
	return( 0 );		// 解除
}

char	DoorCloseChk( void )
{
	if( OPE_SIG_DOOR_Is_OPEN == 0 ){								// ﾄﾞｱ閉?
		if (RAMCLR) {												// メモリイニシャライズ実施？
			return( 99 );											// 再起動案内
		}
		if (prm_get(COM_PRM, S_PAY, 33, 1, 1) == 1) {				// ドア閉時のコイン金庫警告あり
		if( FNT_CN_BOX_SW ){										// ｺｲﾝ金庫ｾｯﾄ?
			return( 0 );											// ｺｲﾝ金庫ｾｯﾄ忘れ
		}
		}
		if (prm_get(COM_PRM, S_PAY, 33, 1, 2) == 1) {				// ドア閉時のコインカセット警告あり
		if( CN_RDAT.r_dat0c[1] & 0x40 ){							// ｺｲﾝｶｾｯﾄ開
			return( 1 );											// ｺｲﾝｶｾｯﾄｾｯﾄ忘れ
		}
		}
		if (prm_get(COM_PRM, S_PAY, 33, 1, 3) == 1) {				// ドア閉時のコインメック鍵警告あり
		if( FNT_CN_DRSW ){											// ｺｲﾝﾒｯｸﾄﾞｱｽｲｯﾁ開(ｺｲﾝﾒｯｸﾄﾞｱｷｰ開)?
			return( 2 );											// ｺｲﾝﾒｯｸﾄﾞｱｷｰ閉め忘れ
		}
		}
		if (prm_get(COM_PRM, S_PAY, 33, 1, 5) == 1) {				// ドア閉時の紙幣リーダー警告あり
		if( NT_RDAT.r_dat1b[0] & 0x02 ){							// ｽﾀｯｶｰ開?
			return( 3 );											// 紙幣ﾘｰﾀﾞｰのﾌﾀ閉め忘れ
		}
		}
		if (prm_get(COM_PRM, S_PAY, 33, 1, 6) == 1) {				// ドア閉時の紙幣金庫鍵警告あり
		if( FNT_NT_BOX_SW ){										// 紙幣金庫脱着ｽｲｯﾁ開?
			return( 4 );											// 紙幣ﾘｰﾀﾞｰの鍵閉め忘れ
		}
		}
		if (prm_get(COM_PRM, S_PAY, 34, 1, 1) == 1) {				// ドア閉時のレシートプリンタ警告あり
		if( 0 != ALM_CHK[ALMMDL_SUB][ALARM_RPAPEROPEN] ){			// ﾚｼｰﾄﾌﾟﾘﾝﾀ蓋開
			return( 5 );
		}
		}
		if (prm_get(COM_PRM, S_PAY, 34, 1, 3) == 1 &&				// ドア閉時のジャーナルプリンタ警告あり
			prm_get(COM_PRM, S_PAY, 21, 1, 1) == 1		) {			// ジャーナルプリンタあり
		if( 0 != ALM_CHK[ALMMDL_SUB][ALARM_JPAPEROPEN] ){			// ｼﾞｬｰﾅﾙﾌﾟﾘﾝﾀ蓋開
			return( 6 );
		}
// MH810104 GG119201(S) 電子ジャーナル対応
		if( 0 != IsErrorOccuerd(ERRMDL_EJA, ERR_EJA_SD_UNAVAILABLE) ) {	// SDカード使用不可
			return( 6 );
		}
// MH810104 GG119201(E) 電子ジャーナル対応
		}
		return( 100 );
	}
	return( 101 );
}

/*[]----------------------------------------------------------------------[]*/
/*| 例外登録                                                               |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : DoorCloseChk                                            |*/
/*| PARAMETER    : md   : Error Module                                     |*/
/*|              : no   : Error No.                                        |*/
/*|              : knd  : 0=解除 1=発生 2=発生/解除                        |*/
/*|              : data : 0=ｴﾗｰ情報無し 1=ｴﾗｰ情報有り(ascii) 2=(bin)       |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : T.Hashimo                                               |*/
/*| Date         : 2005-08-17                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
void
ex_errlg( uchar md, uchar no, uchar knd, uchar data )
{
	if( data != 0 ){												// ｴﾗｰ情報ありの場合
		switch( md ){
		case ERRMDL_MAIN:											// ﾒｲﾝ制御ﾓｼﾞｭｰﾙｺｰﾄﾞ
			memset( &cErrlog, 0, sizeof( cErrlog ) );
			switch( no ){
			case ERR_MAIN_FUSEI_RYOCAL:
			case ERR_MAIN_FKINOUTTIMENG:
			case ERR_MAIN_FKINOUTGYAKU:
			case ERR_MAIN_INOUTGYAKU:
				sprintf( (char*)cErrlog,
					" %04d/%02d/%02d %02d:%02d〜%04d/%02d/%02d %02d:%02d",
					car_in_f.year,car_in_f.mon,car_in_f.day,car_in_f.hour,car_in_f.min,
						car_ot_f.year,car_ot_f.mon,car_ot_f.day,car_ot_f.hour,car_ot_f.min );
				break;
			}
			break;
		case ERRMDL_PRINTER:										// ﾚｼｰﾄ,ｼﾞｬｰﾅﾙﾓｼﾞｭｰﾙｺｰﾄﾞ
			break;
		}
		if( 0 == cErrlog[0] ){										// ﾃﾞｰﾀなし
			err_chk2( (char)md, (char)no, (char)knd, 0, 0, (void*)0L );		// ｴﾗｰﾛｸﾞ登録(補足ﾃﾞｰﾀなし)
		}else{
			err_chk2( (char)md, (char)no, (char)knd, 1, 0, (void*)&cErrlog );	// ｴﾗｰﾛｸﾞ登録(補足ﾃﾞｰﾀあり)
		}
	}
	else{
		err_chk2( (char)md, (char)no, (char)knd, 0, 0, (void*)0L );	// ｴﾗｰﾛｸﾞ登録
	}
}

/*[]----------------------------------------------------------------------[]*/
/*| ｴﾗｰ発生状況取得			                                               |*/
/*[]----------------------------------------------------------------------[]*/
/*|	指定番号のｴﾗｰが発生中か否かを返す									   |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : IsErrorOccuerd( md, no )					               |*/
/*| PARAMETER    : md   : ｴﾗｰ種別(0〜100)                                  |*/
/*|              : no   : ｴﾗｰｺｰﾄﾞ(0〜255)                                  |*/
/*| RETURN VALUE : 1=発生中、0=未発生、0xff=ﾊﾟﾗﾒｰﾀｴﾗｰ                      |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Hara(NT4500EXより流用)                                  |*/
/*| Date         : 2005-02-01                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
uchar	IsErrorOccuerd( char md, char no )
{
	char	moj;

	moj = moj_no[md];
	if( moj == (char)-1 ){												// 各ﾓｼﾞｭｰﾙｂﾌ格納場所
		return	(uchar)0xff;
	}
	if(( moj >= ERR_MOD_MAX)||( no >= ERR_NUM_MAX )){
		return	(uchar)0xff;
	}

	if( 1 == ERR_CHK[moj][no] )										// 発生中
		return	(uchar)1;
	return	(uchar)0;
}

/*[]----------------------------------------------------------------------[]*/
/*| ｴﾗｰ情報取得				                                               |*/
/*[]----------------------------------------------------------------------[]*/
/*|	特定のエラーテーブルの情報を返す									   |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : IsErrorOccuerd( md, no )					               |*/
/*| PARAMETER    : type : 取得したいエラー情報                             |*/
/*| 			 : md   : ｴﾗｰ種別(0〜100)                                  |*/
/*|              : no   : ｴﾗｰｺｰﾄﾞ(0〜255)                                  |*/
/*| RETURN VALUE : エラー情報						                       |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author       : Namioka					                               |*/
/*| Date         : 2011-09-08                                              |*/
/*| Update       :                                                         |*/
/*[]------------------------------------- Copyright(C) 2011 AMANO Corp.---[]*/
ushort	IsErrorInfoGet( char type, char md, char no )
{
	char	moj;
	ushort	ret = 0;
	
	moj = moj_no[md];
	if( moj == (char)-1 ){											// 各ﾓｼﾞｭｰﾙｂﾌ格納場所
		return	ret;
	}
	
	switch( type ){
		case ERR_INFO_ALL:				// 全ての情報
			ret = ErrAct[moj][no].USHORT;
			break;
		case ERR_INFO_LOGREGIST:		// ログ登録			（0=しない，1=する，2=条件によりする，3=未使用)	
			ret = ErrAct[moj][no].BIT.LogRegist;
			break;
		case ERR_INFO_JOURNAL:			// ジャーナル印字1	（0=しない，1=する，2=条件によりする，3=未使用）
			ret = ErrAct[moj][no].BIT.Journal;
			break;
		case ERR_INFO_CLOSE:			// 休業				（0=しない，1=する，2=条件によりする，3=未使用）
			ret = ErrAct[moj][no].BIT.Close;
			break;
		case ERR_INFO_NOTICETOHOST:		// 通信でHostへ通知	（0=しない，1=する，2=条件によりする，3=未使用）
			ret = ErrAct[moj][no].BIT.NoticeToHost;
			break;
		case ERR_INFO_TROUBLESIGOUT:	// トラブル信号出力	（0=しない，1=する，2=条件によりする，3=未使用）
			ret = ErrAct[moj][no].BIT.TroubleSigOut;
			break;
		case ERR_INFO_BIGHORN:			// Bigホーン出力	（0=しない，1=する）※ｱﾗｰﾑ時のみ				
			ret = ErrAct[moj][no].BIT.BigHorn;
			break;
		case ERR_INFO_MUKOU:			// 					（0=有効  ，1=無効）※ｱﾗｰﾑ時のみ				
			ret = ErrAct[moj][no].BIT.Mukou;
			break;
		case ERR_INFO_LEVEL:			// 重要度レベル		（0〜8, 0=低）
			ret = ErrAct[moj][no].BIT.Level;
			break;
	}

	return	ret;
}
/************************************/
/*									*/
/************************************/
ushort	GetErrorOccuerdLevel( char md, char no )
{
	char	moj;
	ushort	ErrLevel= 0;


	moj = moj_no[md];
	if( moj != (char)-1 ){											// 各ﾓｼﾞｭｰﾙｂﾌ格納場所
		//	md = ｴﾗｰ種別(0〜100), no = ｴﾗｰｺｰﾄﾞ(0〜255)
		//	ret = 1=発生中, 0=未発生, 0xff=ﾊﾟﾗﾒｰﾀｴﾗｰ
		if (IsErrorOccuerd(md, no) == 1) {
			//	ErrLevelのｾｯﾄ
			ErrLevel = ErrAct[moj][no].BIT.Level;	//	const t_EAM_Act ErrAct[ERR_MOD_MAX][ERR_NUM_MAX]
		}
	}
	return(ErrLevel);
}

/*[]----------------------------------------------------------------------[]*/
/*| センターに全エラー・アラームを再送する処理                             |*/
/*[]----------------------------------------------------------------------[]*/
/*| MODULE NAME  : Ope_CenterDoorResend                                    |*/
/*| PARAMETER    : void                                                    |*/
/*| RETURN VALUE : void                                                    |*/
/*[]----------------------------------------------------------------------[]*/
/*| Date         : 2013-02-22                                              |*/
/*[]------------------------------------- Copyright(C) 2013 AMANO Corp.---[]*/
void Ope_CenterDoorResend( void )
{
	static const uchar	ucBit[] = { 0x01, 0x02, 0x04, 0x08 };

	uchar	i, j, ucErrWk;
	ushort	sno, smax, errcod;
	ulong	errinfo;

	//------------------------------------------------------------------------
	OPECTL.f_DoorSts = 0;								// ドア閉状態とする。
	//------------------------------------------------------------------------

	for( i = 0; i < ALM_MOD_MAX; i++ ){
		for( j = 0; j < ALM_NUM_MAX; j++ ){
// 不具合修正(S) K.Onodera 2016/10/13 #1505 アラーム01-61(5000円札釣り切れ)発生を含むデータが応答されてしまう
//			if( ALM_CHK[i][j] ){
			if( ALM_CHK[i][j] && isDefToErrAlmTbl(1, i, j) ){
// 不具合修正(E) K.Onodera 2016/10/13 #1505 アラーム01-61(5000円札釣り切れ)発生を含むデータが応答されてしまう
// MH322916(S) A.Iiizumi 2018/07/26 長期駐車検出機能対応
				if( ( i == ALMMDL_MAIN ) && (j == ALARM_LONG_PARKING) ){
					// アラーム種別：０、 コード３１（長期駐車検出）は別途判定する
					continue;
				}
// MH322916(E) A.Iiizumi 2018/07/26 長期駐車検出機能対応
				// アラーム送信
				memcpy( &Arm_work.Date_Time, &CLK_REC, sizeof( date_time_rec ) );	// 発生日時
				Arm_work.Armsyu = i;												// ｱﾗｰﾑ種別
				Arm_work.Armcod = j;												// ｱﾗｰﾑｺｰﾄﾞ
				Arm_work.Armdtc = 1;												// ｱﾗｰﾑ発生/解除
				Arm_work.Armlev = AlmAct[i][j].BIT.Level;							// ｱﾗｰﾑﾚﾍﾞﾙ
				Arm_work.ArmDoor = ERR_LOG_RESEND_F;								// 再送状態とする
				Arm_work.Arminf = 0;												// ｱﾗｰﾑ情報有無

				Log_regist( LOG_ALARM );											// ｱﾗｰﾑﾛｸﾞ登録
			}
		}
	}
// MH322916(S) A.Iiizumi 2018/07/26 長期駐車検出機能対応
// MH322917(S) A.Iiizumi 2018/09/03 長期駐車検出機能の拡張対応(検出部分)
//	LongTermParkingCheck_Resend();//長期駐車検出の再チェック（この中でログ登録も行う）
	LongTermParkingCheck_Resend_flagset();//長期駐車検出の再チェック受付処理
// MH322917(E) A.Iiizumi 2018/09/03 長期駐車検出機能の拡張対応(検出部分)
// MH322916(E) A.Iiizumi 2018/07/26 長期駐車検出機能対応

	WACDOG;																			// WATCHDOGﾀｲﾏｰﾘｾｯﾄ
	for( i = 0; i < ERR_MOD_MAX; i++ ){
		for( j = 0; j < ERR_NUM_MAX; j++ ){
// 不具合修正(S) K.Onodera 2016/10/13 #1505 アラーム01-61(5000円札釣り切れ)発生を含むデータが応答されてしまう
//			if( ERR_CHK[i][j] ){
			if( ERR_CHK[i][j] && isDefToErrAlmTbl(0, i, j) ){
// 不具合修正(E) K.Onodera 2016/10/13 #1505 アラーム01-61(5000円札釣り切れ)発生を含むデータが応答されてしまう
				// エラー送信のため、ここでログ登録する

				if( ( i == mod_flapcrb ) &&
					( j == ERR_FLAPLOCK_LOCKCLOSEFAIL || j == ERR_FLAPLOCK_LOCKOPENFAIL ||	// 開/閉 or 上昇/下降エラー
		 			  j == ERR_FLAPLOCK_DOWNRETRYOVER || j == ERR_FLAPLOCK_DOWNRETRY ) ) {	// 保護処理リトライオーバー/保護処理開始
					// エラー種別：１６（通信タイプ：フラップ／ロック装置）
					continue;
				}
// GM849100(S) 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信（ドア閉時の再登録をしない）
				if( i == mod_alarm ) {
					continue;
				}
// GM849100(E) 名鉄協商コールセンター対応　アラームデータをエラー９６ｘｘで送信（ドア閉時の再登録をしない）

				memcpy( &Err_work.Date_Time, &CLK_REC, sizeof( date_time_rec ) );	// 発生日時
				Err_work.Errsyu = ErrAct_index[i];									// ｴﾗｰ種別
				Err_work.Errcod = j;												// ｴﾗｰｺｰﾄﾞ
				if(( i == mod_lanibk2 )||( i == mod_dopaibk2 )){
					// モジュール 遠隔NT-NET
					Err_work.Errcod = j+100;
				}
				Err_work.Errdtc = 1;												// ｴﾗｰ発生/解除
				Err_work.Errlev = ErrAct[i][j].BIT.Level;							// ｴﾗｰﾚﾍﾞﾙ
				Err_work.ErrDoor = ERR_LOG_RESEND_F;								// 再送状態とする
				Err_work.Errinf = 0;												// ｴﾗｰ情報有無

				Log_regist( LOG_ERROR );											// ｴﾗｰﾛｸﾞ登録
			}
		}
		WACDOG;																		// WATCHDOGﾀｲﾏｰﾘｾｯﾄ
	}

	// エラー種別：１６（通信タイプ：フラップ／ロック装置）上昇／下降ロックの検索
	switch( GetCarInfoParam() ){	// 設定03-0100参照　車、バイク
		case 0x01: // ロックのみ
			sno = BIKE_START_INDEX;						// 100〜
			smax = BIKE_START_INDEX + BIKE_LOCK_MAX;	// 100+50
			break;
		case 0x04: // 車のみ
			sno = INT_CAR_START_INDEX;						// 50〜
			smax = INT_CAR_START_INDEX + INT_CAR_LOCK_MAX;	// 50+20
			break;
		case 0x05: // 両方
		default:
			sno = INT_CAR_START_INDEX;					// 50〜
			smax = BIKE_START_INDEX + BIKE_LOCK_MAX;	// 100+50
			break;
	}

	for( ; sno < smax; sno++ ){

		ucErrWk = flp_err_search( sno, &errinfo );
		if( ucErrWk ){
			// エラー車室あり
			memcpy( &Err_work.Date_Time, &CLK_REC, sizeof( date_time_rec ) );	// 発生日時
			Err_work.Errdtc = 1;												// ｴﾗｰ発生/解除
			Err_work.ErrDoor = ERR_LOG_RESEND_F;								// 再送状態とする
			Err_work.Errinf = 2;												// ｴﾗｰ情報有無
			Err_work.ErrBinDat = (ulong)errinfo;								// ｴﾗｰ情報(bin)
			// 13/4/4追加(S)
			if( 0 == LKcom_RoomNoToType(Err_work.ErrBinDat) ){					// エラーの車室はロック装置
				if( prm_get( COM_PRM, S_PRN, 19, 1, 1 ) == 0 ){					// 18-0019E=1　上昇/下降及び開/閉ロック印字しない
					Err_work.Errinf = 0;										// 付属ﾃﾞｰﾀ(bin)なしとする
				}
			} else { 															// エラーの車種はフラップ
				if( prm_get( COM_PRM, S_PRN, 19, 1, 3 ) == 0 ){					// 18-0019C=1　上昇/下降及び開/閉ロック印字しない
					Err_work.Errinf = 0;										// 付属ﾃﾞｰﾀ(bin)なしとする
				}
			}
			// 13/4/4追加(E)
			for( i = 0; i < 4; i++ ){
				if( ucErrWk & ucBit[i] ){
					switch( ucBit[i] ){
						case 0x01:
							errcod = ERR_FLAPLOCK_LOCKCLOSEFAIL;			// E1638:上昇ロック発生中
							break;
						case 0x02:
							errcod = ERR_FLAPLOCK_LOCKOPENFAIL;				// E1639:下昇ロック発生中
							break;
						case 0x04:
							errcod = ERR_FLAPLOCK_DOWNRETRYOVER;			// E1640:リトライオーバーエラー
							break;
						case 0x08:
							errcod = ERR_FLAPLOCK_DOWNRETRY;				// E1641:リトライ動作開始エラー
							break;
						default:
							continue;
							break;
					}
// MH322914(S) K.Onodera 2017/01/31 AI-V対応：エラーアラーム
					if( isDefToErrAlmTbl(0, (uchar)mod_flapcrb, (uchar)errcod) ){
// MH322914(E) K.Onodera 2017/01/31 AI-V対応：エラーアラーム
					Err_work.Errsyu = ErrAct_index[mod_flapcrb];				// ｴﾗｰ種別
					Err_work.Errcod = errcod;									// ｴﾗｰｺｰﾄﾞ
					Err_work.Errlev = ErrAct[mod_flapcrb][errcod].BIT.Level;	// ｴﾗｰﾚﾍﾞﾙ
					Log_regist( LOG_ERROR );									// ｴﾗｰﾛｸﾞ登録
// MH322914(S) K.Onodera 2017/01/31 AI-V対応：エラーアラーム
					}
// MH322914(E) K.Onodera 2017/01/31 AI-V対応：エラーアラーム
				}
			}
		}
	}
	WACDOG;																	// WATCHDOGﾀｲﾏｰﾘｾｯﾄ
}

// GG120600(S) // Phase9 遠隔監視データ変更
//void wrmonlg(ushort FuncNo, ulong Code, ushort MonInfo, u_inst_no *pInstNo, date_time_rec *pTime1, date_time_rec *pTime2, uchar *pProgNo)
void wrmonlg(ushort FuncNo, ulong Code, ushort MonInfo, u_inst_no *pInstNo, date_time_rec *pTime1, date_time_rec *pTime2, uchar *pProgNo,uchar fromflag,uchar upflag)
// GG120600(E) // Phase9 遠隔監視データ変更
{
	Rmon_log *work;

	work = &RMON_LOG_DAT.Rmon_work;
	memset(work, 0, sizeof(*work));
	memcpy(&work->Date_Time, &CLK_REC, sizeof(date_time_rec));	// 発生日時
	work->Date_Time.Sec = CLK_REC.seco;

	memcpy(&work->RmonInstNo, pInstNo, sizeof(*pInstNo));		// 命令番号
	work->RmonFuncNo = FuncNo;									// 端末機能番号
	work->RmonProcNo = (ushort)(Code / 1000000);				// 処理番号
	work->RmonProcInfoNo = (ushort)(Code / 10000 % 100);		// 処理情報番号
	work->RmonStatusNo = (uchar)(Code / 100 % 100);				// 状況番号
	work->RmonStatusDetailNo = (ushort)(Code % 100);			// 状況詳細番号
	work->RmonInfo = MonInfo;									// 端末監視情報
// GG120600(S) // Phase9 #6180 端末の設定変更時に送信される遠隔監視データ「端末で設定パラメータ変更」の「設定アップロード依頼」の値が0になっている
	work->RmonUploadReq = upflag;								// アップロード要求
// GG120600(E) // Phase9 #6180 端末の設定変更時に送信される遠隔監視データ「端末で設定パラメータ変更」の「設定アップロード依頼」の値が0になっている
// MH321801(S) // Phase9遠隔監視データ変更
	work->RmonFrom = fromflag;									// 
// MH321801(E) // Phase9遠隔監視データ変更

	if (pTime1) {
		memcpy(&work->RmonStartTime1, pTime1, sizeof(*pTime1));	// 予定開始時刻1
	}
	if (pTime2) {
		memcpy(&work->RmonStartTime2, pTime2, sizeof(*pTime2));	// 予定開始時刻2
	}
	if (pProgNo) {
		memcpy(&work->RmonProgNo, pProgNo, sizeof(work->RmonProgNo));	// プログラム部番・バージョン
	}

	Log_regist(LOG_REMOTE_MONITOR);
}

// MH322914(S) K.Onodera 2016/08/30 AI-V対応：エラー・アラーム
/*[]----------------------------------------------------------------------[]*/
/*| エラーレベル取得 ※noはErrAct/ERR_CHKで共通の配列番号なので、エラー種別ではない
/*[]----------------------------------------------------------------------[]*/
ushort getErrLevel( ushort no, ushort code )
{
	return ErrAct[no][code].BIT.Level;
}
ushort getAlmLevel( ushort no, ushort code )
{
	return AlmAct[no][code].BIT.Level;
}
// MH322914(E) K.Onodera 2016/08/30 AI-V対応：エラー・アラーム
// 不具合修正(S) K.Onodera 2016/10/13 #1505 アラーム01-61(5000円札釣り切れ)発生を含むデータが応答されてしまう
/*[]----------------------------------------------------------------------[]*/
/*| エラー/アラームテーブルに定義されているかチェック※noはErrAct/ERR_CHKで共通の配列番号なので、エラー種別ではない
/*[]----------------------------------------------------------------------[]*/
BOOL isDefToErrAlmTbl( uchar type, uchar no, uchar code )
{
	BOOL bRet = FALSE;
	uchar wkuc;

	// エラー？
	if( type == 0 ){
		if( ErrAct[no][code].BIT.NoticeToHost ){
			wkuc = (uchar)prm_get( COM_PRM,S_NTN,37,1,3 );						// エラーデータ 送信レベル設定get
			if( (9 != wkuc) &&													// 送信しない設定ではなく
				(ErrAct[no][code].BIT.Level >= wkuc) ){							// 送信すべきレベル
				bRet = TRUE;
			}
		}
	}
	// アラーム？
	else{
		if( AlmAct[no][code].BIT.NoticeToHost ){
			wkuc = (uchar)prm_get( COM_PRM,S_NTN,37,1,4 );						// アラームデータ 送信レベル設定get
			if( (9 != wkuc) &&													// 送信しない設定ではなく
				(AlmAct[no][code].BIT.Level >= wkuc) ){							// 送信すべきレベル
				bRet = TRUE;
			}
		}
	}

	return bRet;
}
// 不具合修正(E) K.Onodera 2016/10/13 #1505 アラーム01-61(5000円札釣り切れ)発生を含むデータが応答されてしまう
