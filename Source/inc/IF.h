/*[]----------------------------------------------------------------------[]*/
/*|		新I/F盤（親機、子機）共通ヘッダ									   |*/
/*|		・ここには、新I/F盤（親機と子機）が共通に使用する定数を定義します。|*/
/*|		・また、新I/F盤（親機と子機）が共通に使用する「電文フォーマット」を|*/
/*|		  宣言します。													   |*/
/*|																		   |*/
/*[]----------------------------------------------------------------------[]*/
/*| Author      :  T.Hayase		                                           |*/
/*| Date        :  2005-01-18                                              |*/
/*| Update      :                                                          |*/
/*[]------------------------------------- Copyright(C) 2005 AMANO Corp.---[]*/
#ifndef IF_H
#define IF_H


/*----------------------------------*/
/*			条件コンパイル			*/
/*----------------------------------*/
/*
*	2005.05.11 秋葉さんより依頼
*	★精算機シミュレータ使用による評価向け
*	①精算機への送信電文『CRC』を「ffH, ffH」固定値にする。		PAYnt_net.c
*	②精算機への送信電文『データ追い番』を「00H」固定値にする。	PAYnt_net.c, PAYcom.c
*/
#define	QA_FOR_SIM	0				/* 1=シミュレータ使用する・・・・評価実施時 */
									/* 0=シミュレータ使用しない・・・本番 */

/* 子機「ヘッダ文字取り逃がし」検証用 */
#define	DBG_NO29	0				/* 1=ヘッダ文字は固有（子が特定のヘッダ文字を使用する）・・・上記検証時 */
									/* 0=ヘッダ文字は正規・・・本番 */

/*
*	デバッグ・ログ出力とCRCチェックなし（デバッグ用）
*	・予備DIP-SWを使い、デバッグ・ログ出力する/しないを選択可能
*		(親)DIP-SW2の５	ONでログ出力する、OFFでログ出力しない。
*		(子)DIP-SWの５	ONでログ出力する、OFFでログ出力しない。
*
*	・予備DIP-SWを使い、CRCチェックする/しないを選択可能
*		(親)DIP-SW2の６	ONでCRCチェックなし、OFFでCRCチェックあり。
*		(子)DIP-SWの６	ONでCRCチェックなし、OFFでCRCチェックあり。
*/
#define	IF_DEBUG	1				/* 1=上記デバッグのため「予備DIP-SW」を使用する。・・・デバッグ時 */
									/* 0=「予備DIP-SW」を使用しない・・・本番 */

/*
*	2005.04.27(水)
*	★ベンチマークテスト
*	①10msecインターバルタイマーを検証する。
*	②子機応答時間を検証する。
*	・以下の3ファイルに関わります。
*		1)LCC_10msInt(LCCtime.c)				・・・①
*		2)toMcomdr_CharSetToRcvArea(toMcomdr.c)	・・・②
*		3)toMcom_WaitSciSendCmp(toMcom.c)		・・・③
*	・①には、車室＝６の施錠（ロックしろ）信号出力ポート（PF4）を使うので、注意のこと。
*	・②には、車室＝６の開錠（ロック解除）信号出力ポート（PF5）を使うので、注意のこと。
*	・本番は、=0 とするか、シンボル自体をコメントアウトすること。
*/
#define	DBG_BENCH_MARK_TEST		0	/* 1=ベンチマークする・・・・テスト実施 */
									/* 0=ベンチマークしない・・・本番 */


/*----------------------------------*/
/*			value define			*/
/*----------------------------------*/
/*
*	親機・接続台数：
*	・精算機につながる「（親機）接続台数」は、未使用。
*	 （I/F盤が押えるべき情報ではないため）
*
*	子機・接続台数：
*	実装接続子機12台＋予備３台＝15台分
*	・領域確保のとき「IF_SLAVE_MAX」を使用する。
*	・実装する子機は「IF_SLAVE_MAX_USED」を使用する。
*
*	ロック装置・接続台数：（１台の子機につながる車室数）
*	実装６台＋予備２台＝８台分
*	・領域確保のとき「IFS_ROOM_MAX」を使用する。
*	・親機がロック装置No,から、そのロック装置はどの子機所有なのか？を特定するとき「IFS_ROOM_MAX_USED」を使用する。
*	・初期設定データにてもらうべき？を考えたが、８台に増すときには、再コンパイル＋ROM書き換えが必要。
*	・子機基板には６台分のポートしか実装しない。８台に増すときには、ハード改造が必至。
*
*	ロック装置・接続台数：（１台の親機につながる車室数）
*	実装ロック装置６台×実装接続子機12台＝72台分
*	・領域確保のとき「IFM_ROOM_MAX」を使用する。
*	・実装するロック装置は「IFM_ROOM_MAX_USED」を使用する。
*/
#define	IF_SLAVE_MAX			31		/* フラップ・CRB（子機）接続台数 */
#define	IF_SLAVE_MAX_USED		9		// 新I/F盤（子機）接続台数・・・実際に使用する上限 UT8500 I/F盤制御機能仕様書には9台と規定されているので9台とする
#define	IFS_ROOM_MAX			 8		/* ロック装置接続台数（１台の子機につながる車室数）*/
#define	IFS_ROOM_MAX_USED		 6		/* ロック装置接続台数（１台の子機につながる車室数・・・実際に使用する上限）*/
#define	IFM_ROOM_MAX		(IFS_ROOM_MAX_USED * IF_SLAVE_MAX)		/*<90>ロック装置接続台数（１台の親機につながる車室数）*/
#define	IFM_ROOM_MAX_USED	(IFS_ROOM_MAX_USED * IF_SLAVE_MAX_USED)	/*<72>ロック装置接続台数（１台の親機につながる車室数）・・・実際に使用する上限）*/
#define	IFS_CRR_MAX			   3	/* CRR基板の接続最大数（CRR基盤が精算機につながる枚数）*/
#define	IFS_CRRFLAP_MAX		  15	/* CRR基板への接点数（１台のCRRにつながる車室数）*/
#define	IFS_CRR_OFFSET		 100	/* CRR基板へのアクセス用オフセット値 */
#define	TOSCOM_INIT_TIME_FIRST		 3 * 100	// 初期設定送信タイマー 起動時1回目は3秒 (10ms単位)
#define	TOSCOM_INIT_TIME			60 * 100	// 初期設定送信タイマー 60秒毎に送信 (10ms単位)

/*（親機にとって）精算機通信向け：送受信バッファ長 */
#define	PAY_SCI_SNDBUF_SIZE		(20+5+960+2+ 16)	//20=ヘッダ部、5=データ部のヘッダ、960=(ボディ)データMAX、2=CRC、16=予備
#define	PAY_SCI_RCVBUF_SIZE		(20+5+204+2+ 16)	//同上。204=初期設定データ長（最長）

/*（親機にとって）子機通信向け：送受信バッファ長 */
#define	TOS_SCI_SNDBUF_SIZE		(10+250+2+ 16)		//10=ヘッダ部、250=(ボディ)データMAX、2=CRC、16=予備
#define	TOS_SCI_RCVBUF_SIZE		(10+250+2+ 16)		//同上

/*（子機にとって）親機通信向け：送受信バッファ長 */
#define	TOM_SCI_SNDBUF_SIZE		(10+250+2+ 16)		//10=ヘッダ部、250=(ボディ)データMAX、2=CRC、16=予備
#define	TOM_SCI_RCVBUF_SIZE		(10+250+2+ 16)		//同上

/* 親子間シリアル通信ポート設定 */
//#define	IF_SCI_SET_BPS		1		/* DIP-SW：伝送速度(bps)	 0=2400,  1=9600, 2=19200, *3=38400 */
#define	IF_SCI_SET_DBITS		0		/* 固定：  データ長			*0=8bits, 1=7bits 			*/
#define	IF_SCI_SET_SBITS		0		/* 固定：  ストップビット	*0=1bit,  1=2bits			*/
#define	IF_SCI_SET_PBIT			0		/* 固定：  パリティ			*0=none,  1=odd,  2=even 	*/

/************************
*	ロック装置接続状態	*
*************************/
enum LOCK_MAKER {
	LOCK_Nothing = 0,					/*  0：接続無し															*/
	LOCK_AIDA_bicycle,					/*  1：接続有り（株式会社英田エンジニアリング製ロック装置（自転車））	*/
	LOCK_AIDA_bike,						/*  2：接続有り（株式会社英田エンジニアリング製ロック装置（バイク））	*/
	LOCK_YOSHIMASU_both,				/*  3：接続有り（株式会社吉増製作所製ロック装置（自転車、バイク兼用））	*/
	LOCK_KOMUZU_bicycle,				/*  4：接続有り（コムズジャパン製ロック装置（自転車））					*/
	LOCK_HID_both,						/*  5：接続有り（HID製ロック装置（自転車、バイク兼用））				*/

	LOCK_MAKER_END						/*  6：エンドサイン */
};

/************************
*	フラップ装置接続状態	*
*************************/
enum FLAP_MAKER {
	FLAP_Nothing = 0,					// 0：接続無し
	FLAP_SANICA,						// 1: サニカ
	
	FLAP_MAKER_END,
};
/********************
*	デフォルト値	*
*********************/
//ロック装置について
#define	IF_DEFAULT_LOCK_MAKER	LOCK_Nothing	/*  0：接続無し	ロック装置の接続（状態）*/
#define	IF_DEFAULT_ENTRY_TIME			 4		/*  4： 4秒		入庫車両検知タイマー値 */
#define	IF_DEFAULT_EXIT_TIME			 4		/*  4： 4秒		出庫車両検知タイマー値 */
#define	IF_DEFAULT_RETRY_TIMES			 1		/*  1： 1回		ロック装置動作にてリトライする回数 */
#define	IF_DEFAULT_RETRY_INTER			15		/*  1：15秒		ロック装置動作にてリトライする間隔 */

//対精算機通信パラメータ
#define	IF_DEFAULT_toPAY_RECV_LIMIT		100		/*100：1000msec	受信データ最大時間				2005.07.25 調整(←500msec) */
#define	IF_DEFAULT_toPAY_ANSWER_LIMIT	30		/* 30： 300msec	テキスト送信後の応答待ち時間	2005.06.27 調整(←50msec) */
												/*
												*	2005.07.25
												*	※I/F盤の「回線監視」は、テキスト送信後から
												*	  応答受信し始めでは無く、応答受信完了までの時間となる。
												*	・IBK流用の受信アルゴリズムのため、
												*	  受信割り込みハンドラ内で、受信しながら電文解析するのではなく
												*	  受信完了後、電文解析するので、このような解釈をせざるを得ない。
												*	・テキスト送信後の応答が「ACK/NAK/EOT」の場合、電文長が短いので、さほど問題にならないが
												*	  テキスト送信後の応答が「テキストで、かつ初期設定データ」のような長い電文の場合、
												*	  電文受信完了前に『応答待ち時間』タイムアウトを起こすケースがある。
												*	 （イニシャル無しDIP-SW起動で、この不具合となった・・・このときは100msec<19200bps>だった）
												*	・NT-NETプロトコルでは、主局からのセレクティングに対し、
												*	  従局が「データあり」のとき、ACKの代わりにSTX電文で応答し、
												*	  主局は次に「送りたいデータ」をSTX電文にて送ってくる。
												*	・従局からすると、テキスト送信後の応答は、ACKの代わりにSTX電文で応答される事になり
												*	  このSTX電文が「初期設定データ」だったので、『応答待ち時間』タイムアウトを起こした。
												*	・このような変則プロトコルを採用したため、予期せぬ事が起こりうる。
												*
												*	★このような事情は、I/F盤固有の問題なので、
												*	  「受信データ最大時間」＋「テキスト送信後の応答待ち時間」＝タイマ値として採用する。
												*	  ことで、上記不具合を回避する。
												*
												*	☆伝送速度による電文受信完了までの時間を、参考として以下に記す。
												*	  「初期設定データ（20+5+204+2=231）」の場合、
												*		 2400bps：4.167(１ｷｬﾗｸﾀ転送時間)msec × 231ﾊﾞｲﾄ ＝ 962.577 ≒ 963msec
												*		 9600bps：1.042(１ｷｬﾗｸﾀ転送時間)msec × 231ﾊﾞｲﾄ ＝ 240.702 ≒ 241msec
												*		19200bps：0.512(１ｷｬﾗｸﾀ転送時間)msec × 231ﾊﾞｲﾄ ＝ 118.271 ≒ 119msec
												*		38400bps：0.260(１ｷｬﾗｸﾀ転送時間)msec × 231ﾊﾞｲﾄ ＝  60.060 ≒  61msec
												*/
#define	IF_DEFAULT_toPAY_SEND_WAIT		 1		/*  1： 10msec	送信データWaitタイマー */
#define	IF_DEFAULT_toPAY_DATA_RETRY		10		/* 10： 10回	データ送信再送回数 */
#define	IF_DEFAULT_toPAY_NAK_RETRY		 3		/*  3：  3回	NAK送信再送回数 */

//対子機通信パラメータ
#define	IF_DEFAULT_38400_LINE_WATCH			 6	/*  6： 60msec	通信受信(回線)監視タイマ（38400bps）*/
#define	IF_DEFAULT_19200_LINE_WATCH			10	/* 10： 100msec	通信受信(回線)監視タイマ（19200bps）*/
#define	IF_DEFAULT_9600_LINE_WATCH			20	/* 20： 200msec	通信受信(回線)監視タイマ（ 9600bps）*/
#define	IF_DEFAULT_2400_LINE_WATCH			30	/* 30： 300msec	通信受信(回線)監視タイマ（ 2400bps）*/
#define	IF_DEFAULT_toSLAVE_POLLING			 0	/*  0：  0msec	POL/SEL間隔 */
#define	IF_DEFAULT_toSLAVE_RETRY			 3	/*  3：  3回	データ再送回数 */
#define	IF_DEFAULT_toSLAVE_SKIP_NO_ANSWER	10	/* 10： 10回	無応答エラー判定回数 */

#define	IF_DEFAULT_toSLAVE_POLLING_ALONE	10	/* 10：100msec	ひとりっきりの例外 POL/SEL間隔 */

#define	IF_DEFAULT_SLAVE_ANSWER_TIME		10	/* 10：10msec	子機が、親機から状態要求を受け、応答するまでの実測値 */
												/*              ・子機ベンチマークテストにて、親機からの電文受信完了～応答電文送信完了までの時間 */
												/*              ・対象電文は、親機からの「状態データ要求」と、子機よりの「子機状態データ」とする */
//I/F盤全般のシリアル通信
#define	IF_DEFAULT_SEND_WAIT_TIME		2		//  2： 4msec	送信ウェイトタイマ タイマの最少単位が2msより
												/*	2005.06.14 早瀬・追加 */
												/*	親子間ヘッダ文字取り逃がし対処として「3msecの送信待ち」に決定 */
												/*	その根拠は以下。*/
												/*	・文字間タイムアウトが発生したら、電文の末尾まで受信した(受信完了)と認識する */
												/*	「IBKを踏襲」したアルゴリズムを採用している関係で、*/
												/*	・文字間タイマーは、1msecインターバルタイマを使っており、*/
												/*	・親と他の子機、さらに自分の送信待ちがそれぞれ1msecの誤差ありとして、合計＝3msec */

/********************************
*	精算機・新I/F盤(親機)間		*
*********************************/
/*	伝送制御コード（NT-NET）*/
#define	PAY_SOH				0x01
#define	PAY_STX				0x02
#define	PAY_ETX				0x03
#define	PAY_EOT				0x04
#define	PAY_ENQ				0x05
#define	PAY_NAK				0x15
#define	PAY_ACK				0x06

/* 電文タイプ */
#define	PAY_POL_BLCK		('P')	/* 'P'olling:  <0x50>まとめ）ポーリングコード/ENQ電文 */
#define	PAY_POL_QFULL_BLCK	('Q')	/* 'Q'ueue:    <0x51>まとめ）ポーリングコード/ENQ電文（キューFULL）*/
#define	PAY_SEL_BLCK		('S')	/* 'S'electing:<0x53>まとめ）セレクティングコード/ENQ電文 */
#define	PAY_SEL_QFULL_BLCK	('q')	/* 'q'ueue:    <0x71>まとめ）セレクティングコード/ENQ電文（キューFULL）*/
#define	PAY_BC_BLCK			('B')	/* 'B'roadcast:<0x42>まとめ）同報ENQ電文 */
#define	PAY_EOT_BLCK		('E')	/* 'E'ot:      <0x45>まとめ）ACK電文 */
#define	PAY_ACK_BLCK		('A')	/* 'A'ck:      <0x41>まとめ）ACK電文 */
#define	PAY_NAK_BLCK		('N')	/* 'N'ak:      <0x4E>まとめ）NAK電文 */
#define	PAY_TEXT_OK_BLCK	('T')	/* 'T'ure:     <0x54>まとめ）正常テキスト */
#define	PAY_TEXT_NG_BLCK	('F')	/* 'F'lase:    <0x46>まとめ）異常テキスト */
#define	PAY_CONTINUE		('C')	/* 'C'ontinue: <0x43>まとめ）電文受信途中（未確定のため解析不能）*/
#define	PAY_OTHER_BLCK		('O')	/* 'O'ther:    <0x4F>まとめ）自身宛てでは無い */
#define	PAY_ILLEAGL_BLCK	('I')	/* 'I'llegal:  <0x49>まとめ）その他の異常電文 */

/* ヘッダ文字列 */
#define	NT_HEADER_STR		"NTCOM"
#define	NT_HEADER_LEN		5

/********************************
*	新I/F盤(親子)間				*
*********************************/
/* 伝送制御コード */
#define	IF_ACK				0x06
#define	IF_NAK				0x15

/* ヘッダ文字列 */
#define	IF_HEADER_STR		"IFCOM"
#define	IF_HEADER_LEN		5

/************************************
*	CRC16-CCITT
*	・算出関数呼び出し時には、「右シフト」を指定する
*************************************/
#define	CRC16_R_SHIFT		1

/************************************
*	キューの数
*	・ポーリング応答待ちリスト
*	・セレクティング待ちリスト
*	・子機状態リスト
*	・ロック動作完結待ちリスト
*************************************/
#define		PAY_Q_WAIT_ANSWER		(IF_SLAVE_MAX + 1)	/* ポーリング応答待ちリスト */
#define		TOS_Q_WAIT_SELECT		(IF_SLAVE_MAX + 1)	/* セレクティング待ちリスト */
#define		LCM_Q_SLAVE_STATUS		(IF_SLAVE_MAX + 1)	/* 子機状態リスト */
#define		LCM_Q_WAIT_ACTION		(IFM_ROOM_MAX + 1)	/* ロック動作完結待ちリスト */

/*
*	一つの親が、ロック装置の動作完結を待たずに次の動作要求を子に指示できる最大数
*	・最初は１つでも動作中なら、待たせる。
*	・将来は増える可能性あり。
*/
#define		IF_ACTION_MAX			2

/*	・ロック装置動作に伴い、その動作完結を待つまでの制限時間は、*/
/*	  開/閉信号出力時間＋αであるが、その「＋α」時間（ミリ秒）*/
#define		IFS_ANSWER_WAIT_TIME	(10 * IF_SLAVE_MAX) + 100	/* 10msec単位 */

/*	・精算機よりバージョン要求されて応答するまでの制限時間（秒）*/
#define		IFS_VERSION_WAIT_TIME	10	// 10秒

/*
*	2005.06.17 早瀬・削除
*	★以下の制限時間は、ロック装置の動作信号出力時間に依存するため、
*	  一律には特定できない。
*	  よって、信号出力時間から算出する事にし、定数を廃する。
*/
/*	・精算機より全ロック開/閉要求されて応答するまでの制限時間（秒）*/
/*	・精算機より個別ロック開/閉テスト要求されて応答するまでの制限時間（秒）*/
/*	・精算機より全ロック開/閉テスト要求されて応答するまでの制限時間（秒）*/

/*
*	エラー詳細コード
*
*/
/* 親の内部または、精算機通信に対して */
enum {
	E_IFM_BEGIN,				//内部管理番号は「1」から始める
//受信エラー（割り込み検知）
	E_PAY_Parity,				//[ 1：同時]パリティ
	E_PAY_Frame,				//[ 2：同時]フレーミング
	E_PAY_Overrun,				//[ 3：同時]オーバーラン

//電文異常
	E_PAY_PACKET_Timeover,		//[ 4：同時]受信制限時間越え
	E_PAY_PACKET_Headerless,	//[ 5：同時]ヘッダ長まで受信しなかった（文字間が空いた）
	E_PAY_PACKET_HeadStr,		//[ 6：同時]ヘッダ文字異常
	E_PAY_PACKET_DataSize,		//[ 7：同時]データサイズと受信長が不一致
	E_PAY_PACKET_WrongCode,		//[ 8：同時]制御コード不当
	E_PAY_PACKET_CRC,			//[ 9：同時]CRC異常
	E_PAY_PACKET_WrongKind,		//[10：同時]不当(データ種別)電文
	E_PAY_PACKET_DUPLICATE,		//[11：同時]「追い番」が前回電文と重複している

//手順異常
	E_NT_NET_Protocol,			//[12：同時]プロトコル異常
	E_PAY_NAK_Retry,			//[13：同時]NAK(送信)リトライオーバー
	E_PAY_NO_Answer,			//[14：同時]送信リトライオーバー(無応答)

//メモリ不備
	E_PAY_QFULL_PollingWait,	//<15：個別>キューフル（精算機ポーリング応答待ち）
	E_IFM_QFULL_SlaveStatus,	//<16：個別>キューフル（子機状態リスト）
	E_IFM_QFULL_LockAction,		//<17：個別>キューフル（ロック動作待ちリスト）
	E_IFS_QFULL_SelectingWait,	//<18：個別>キューフル（子機セレクティング待ち）

//電文データ不備
	E_IFM_INIT_Data,			//[19：同時]初期設定データ異常
	E_IFM_CTRL_Command,			//[20：同時]制御データ異常

//掟破り
	E_IFM_TEST_Next,			//[21：同時]動作指示異常

//？
	E_IFM_MODE_Change,			//[22：同時]モード切替異常
	E_IFM_Password,				//[23：同時]パスワード破壊

//プログラム不備
	E_IFM_BUG,					//[24：同時]バグかも？

//エンドサイン
	E_IFM_END
};

/* 子に対して */
enum {
	E_IFS_BEGIN,				//内部管理番号は「1」から始める
//受信エラー（割り込み検知）
	E_IFS_Parity,				//[ 1：同時]パリティ
	E_IFS_Frame,				//[ 2：同時]フレーミング
	E_IFS_Overrun,				//[ 3：同時]オーバーラン

//電文異常
	E_IFS_PACKET_Headerless,	//[ 4：同時]ヘッダ長まで受信しなかった（文字間が空いた）
	E_IFS_PACKET_HeadStr,		//[ 5：同時]ヘッダ文字異常
	E_IFS_PACKET_WrongSlave,	//[ 6：同時]相手違い（正規の応答相手では無い）
	E_IFS_PACKET_DataSize,		//[ 7：同時]データサイズと受信長が不一致
	E_IFS_PACKET_CRC,			//[ 8：同時]CRC不一致
	E_IFS_PACKET_WrongKind,		//[ 9：同時]不当(データ種別)電文

//手順異常
	E_IF_Protocol,				//[10：同時]プロトコル異常
	E_IFS_NAK_Retry,			//[11：同時]送信リトライオーバー(NAK)
	E_IFS_NO_Answer,			//<12：個別>送信リトライオーバー(無応答)

//プログラム不備
	E_IFS_BUG,					//[13：同時]バグかも？

//エンドサイン
	E_IFS_END
};

/* エラー状態 */
enum {
	E_IF_RECOVER,	//=0：エラー解除
	E_IF_OCCUR,		//=1：エラー発生
	E_IF_BOTH		//=2：発生解除・同時
};

/*----------------------------------*/
/*		area style define			*/
/*----------------------------------*/
#pragma pack
/*
*	通信電文なので、構造体メンバの境界調整数を「1」とする。
*	・全てバイト列でなくてはならない。
*	・2バイト整数、4バイト整数、実数などを含まない様に注意すること。
*/

/* (65H)エラー状態データの「親機」エラー状態ビットマップ */
typedef struct {
	ushort	bfReserved            :12;	/* bit4～15：予備 */
	ushort	bfQFull_SelectingWait :1;	/* bit3：キューフル（子機セレクティング待ち）*/
	ushort	bfQFull_LockAction    :1;	/* bit2：キューフル（ロック動作待ちリスト）*/
	ushort	bfQFull_SlaveStatus   :1;	/* bit1：キューフル（子機状態リスト）*/
	ushort	bfQFull_PollingWait   :1;	/* bit0：キューフル（精算機ポーリング応答待ち）*/
} t_IFM_bfError;

/* (65H)エラー状態データの「子機」エラー状態ビットマップ */
typedef struct {
	ushort	bfReserved            :15;	/* bit1～15：予備 */
	ushort	bfNO_Answer           :1;	/* bit0：送信リトライオーバー(無応答) */
} t_IFS_bfError;

/************************************
*	精算機・親機間					*
*	通信電文フォーマット			*
*************************************/






/**************************************************************
*	NT-NET通信向け
*	基本テキスト電文フォーマット
*	・テキストボディ部とは？
*		注）データ部の『データ本体』のこと。
*			データ部は「テキストヘッダ部」と
*					  「テキストボディ部」となら成る。テキストボディ部はCRC(2バイト)を含む。
*
*	・データサイズ＝ヘッダ長(20)＋データ長(9～967)－CRC長(2)・・・（CRCは含まず）
*		  ヘッダ長＝20バイト
*		  データ長＝テキストヘッダ長(5)＋テキストボディ長（MAX=960）
*			 CRC長＝ 2バイト
*
*	テキストボディ部（データ種別により異なる）
*	・コマンド（精算機→親機）
*		(23H)初期設定データ									＝206（CRC含む）
*		(21H)ロック装置制御データ							＝7  （CRC含む）
*
*	・応答（親機⇒精算機）
*		(22H)I/F盤要求データ								＝4  （CRC含む）
*	  変(61H)通常状態データ									＝454（CRC含む）
			※複数ブロックにすることはしない。（次のポーリング時に残りを応答する）
*			・指定ロック装置・センサー状態応答
*			・接続全ロック装置・センサー状態応答
*			・接続全ロック装置・開/閉応答
*		(62H)ロック装置・開/閉テスト応答(全て・指定共通)	＝93 （CRC含む）
*		(63H)メンテナンス情報要求応答						＝867（CRC含む）
*	  追(64H)バージョン要求応答								＝131（CRC含む）
*	  追(65H)エラー状態データ								＝35 （CRC含む）
*	  追(66H)エラーデータ									＝6  （CRC含む）
***************************************************************/

/************************************
*	新I/F盤・親子間					*
*	通信電文フォーマット			*
*************************************/
/****************************************
* 子機センサー状態
*	2005.03.04 早瀬・変更
*	bit3：(=0)動作停止を廃したので、意味を持たなくなったが、
*	代わりに動作が終わったか？否かを反映する「状態」と意味付けた。
*****************************************/
typedef union {
	struct {
		uchar	      B7:1;		/*	bit7：メンテナンスモード	0=通常運用/1=メンテナンス			2005.03.30 早瀬・追加 */
		uchar	reserved:2;		/*	bit6：予備					0=固定											*/
								/*	bit5：予備					0=固定											*/
		uchar	      B4:1;		/*	bit4：ロック装置動作方向	0=閉動作方向/1=開動作方向						*/
		uchar	      B3:1;		/*	bit3：ロック装置動作状態	0=動作完結/1=動作中	(書き込み不可)	2005.03.04 早瀬・変更 */
		uchar	      B2:1;		/*	bit2：車両検知センサー状態	0=OFF/1=入庫ON		(書き込み不可)				*/
		uchar	      B1:1;		/*	bit1：ロック閉センサー状態	0=OFF/1=施錠ON		(書き込み不可)				*/
		uchar	      B0:1;		/*	bit0：ロック開センサー状態	0=OFF/1=開錠ON		(書き込み不可)				*/
	}		Bit;				/* ビットアクセス */
	uchar	Byte;				/* バイトアクセス */
} t_IF_LockSensor;

/****************************************
* 子機センサー状態
*	2005.03.04 早瀬・変更
*	bit3：(=0)動作停止を廃したので、意味を持たなくなったが、
*	代わりに動作が終わったか？否かを反映する「状態」と意味付けた。
*****************************************/
typedef struct{
	uchar	c_LoopSensor;			// ループセンサ状態 '0':未使用
									//					'1':OFF状態
									//					'2':ON状態
									//					'3':異常
									//					'4':強制OFF状態
									//					'5':強制ON状態
									//					'6':不明状態
	uchar	c_ElectroSensor;		// 電磁センサ状態 	'0':未使用
									//					'1':OFF状態
									//					'2':ON状態
	uchar	c_LockPlate;			// ロック板状態		'0':待機中
									//					'1':下降中
									//					'2':上昇中
									//					'3':下降エラー（下降中にエラーが発生）
									//					'4':上昇エラー（上昇中にエラーが発生）
									//					'5':強制下降
									//					'6':強制上昇
									//					'8':不正ロック
	uchar	c_FlapSensor;			//					'0':中間
									//					'1':下降
									//					'2':上昇
									//					'3':異常
} t_IF_FlapSensor;

typedef struct {					// ループカウンタ
	uchar	ucLoopCount[4];			// ループカウント
	uchar	ucOffBaseCount[4];		// オフベースカウント
	uchar	ucOnLevelCount[4];		// オンレベルカウント
	uchar	ucOffLevelCount[4];		// オフレベルカウント
	uchar	ucOnBaseCount[4];		// オンベースカウント
} t_IF_FlatLoopCounter;

typedef struct {
	struct {																/*								*/
		struct {
			ulong	ulAction;		/* 開閉動作の合計回数（自動・手動の合計、閉して開すると2回と数える）		*/
			ulong	ulManual;		/* I/F盤SWによる手動での開・閉動作合計回数									*/
			ulong	ulTrouble;		/* 故障した合計回数（リミットSW状態が変化しない等）							*/
		} sLock[IFS_ROOM_MAX];
	} sSlave[IF_SLAVE_MAX];
} t_IF_LockAction;

/****************************************
*	ヘッダ部分（共通）
*	・データ長＝10バイト
*****************************************/
typedef struct {
	uchar	c_String[5];			/* ヘッダ文字列						"IFCOM"固定								*/
	uchar	c_Size[2];				/* データサイズ（ヘッダ文字列先頭からBCCまでのサイズ。バイナリ）			*/
	uchar	c_Kind[1];				/* データ種別																*/
									/*		（49H：'I'）初期設定データ		（親機→子機）						*/
									/*		（52H：'R'）状態要求データ		（親機→子機）						*/
									/*		（57H：'W'）状態書込みデータ	（親機→子機）						*/
									/*		（06H：ACK）肯定応答データ		（子機⇒親機）						*/
									/*		（15H：NAK）否定応答データ		（子機⇒親機）						*/
									/*		（41H：'A'）子機状態データ		（子機⇒親機）						*/
									/*		（56H：'V'）子機バージョンデータ（子機⇒親機）						*/
	uchar	c_TerminalNo[2];		/* I/F盤（子機）のターミナルNo.		（"01"～"15"）							*/
} t_IF_Header;

/****************************************
*	親機→子機
*	（49H：'I'）初期設定データ
*	・データ長＝14バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Connect[IFS_ROOM_MAX];/* ロック装置の接続（状態）													*/
									/* [0]ロック装置No.1														*/
									/* [6]ロック装置No.7（予備）												*/
									/* [7]ロック装置No.8（予備）												*/
									/*	'0'：接続無し															*/
									/*	'1'：接続有り（株式会社英田エンジニアリング製ロック装置（自転車））		*/
									/*	'2'：接続有り（株式会社英田エンジニアリング製ロック装置（バイク））		*/
									/*	'3'：接続有り（株式会社吉増製作所製ロック装置（自転車、バイク兼用））	*/
									/*	'4'：接続有り（コムズジャパン製ロック装置（自転車））					*/
									/*	'5'：接続有り（HID製ロック装置（自転車、バイク兼用））					*/
	uchar	c_EntryTimer[2];		/* 入庫車両検知タイマー				 (車両検知確定時間  ＝"01"～"99" 秒)	*/
	uchar	c_ExitTimer[2];			/* 出庫車両検知タイマー				 (車両非検知確定時間＝"01"～"99" 秒)	*/
//CRC
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット	*/
									/*	[1]：CRC16ビットの上位8ビット	*/
} t_IF_Body_I49;

/****************************************
*	親機→子機
*	（52H：'R'）状態要求データ
*	・データ長＝3バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Request[1];			/* 要求内容		（'0'～'F'）		*/
									/*	 	 '0'：子機状態データ要求	*/
									/*		 '1'：バージョン要求		*/
									/*	'2'～'F'：予備					*/
//CRC
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット	*/
									/*	[1]：CRC16ビットの上位8ビット	*/
} t_IF_Body_R52;

/****************************************
*	親機→子機
*	（57H：'W'）状態書込みデータ
*	・データ長＝9バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_LockOnTime[2];		/* ロック装置閉時の信号出力時間（×150msec）	（"01"～"99"）				*/
	uchar	c_LockOffTime[2];		/* ロック装置開時の信号出力時間（×150msec）	（"01"～"99"）				*/
	uchar	c_RoomNo[1];			/* ロック装置No.（予備含む）					（'1'～'8'）				*/
	uchar	c_MakerID[1];			/* ロック装置メーカーID（初期設定データの「ロック装置の接続」同様）		2005.03.30 早瀬・追加 */
t_IF_LockSensor	unCommand;			/* 書き込みセンサー状態（バイナリ）											*/
									/*		bit0：ロック開センサー状態	0=OFF/1=ON（書き込み不可）				*/
									/*		bit1：ロック閉センサー状態	0=OFF/1=ON（書き込み不可）				*/
									/*		bit2：車両検知センサー状態	0=OFF/1=ON（書き込み不可）				*/
									/*		bit3：ロック装置動作状態	0=動作完結/1=動作中	(書き込み不可)	2005.03.04 早瀬・変更 */
									/*		bit4：ロック装置動作方向	0=閉動作方向/1=開動作方向				*/
									/*		bit5：予備					0=固定（書き込み不可）					*/
									/*		bit6：ガード時間指示ビット	1=固定									*/
									/*		bit7：メンテナンスモード	0=通常運用/1=メンテナンス			2005.03.30 早瀬・追加 */
//CRC
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット	*/
									/*	[1]：CRC16ビットの上位8ビット	*/
} t_IF_Body_W57;

/****************************************
*	子機⇒親機
*	（06H：ACK 制御コード）肯定応答データ
*	・データ長＝3バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Request[1];			/* 要求内容		（'0'～'F'）		*/
									/*		 '0'：固定					*/
									/*	'1'～'F'：予備					*/
//CRC
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット	*/
									/*	[1]：CRC16ビットの上位8ビット	*/
} t_IF_Body_ACK;

/*
*	子機⇒親機
*	（15H：NAK 制御コード）否定応答データ
*	・データ長＝3バイト（CRC含む）
*/
typedef struct {
	uchar	c_Request[1];			/* 要求内容		（'0'～'F'）								*/
									/*		 '0'：電文(BCC/データ長)異常						*/
									/*		 '1'：初期設定データ要求（初期設定データ未受信）	*/
									/*	'2'～'F'：予備											*/
//CRC
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット							*/
									/*	[1]：CRC16ビットの上位8ビット							*/
} t_IF_Body_NAK;

/****************************************
*	子機⇒親機
*	（41H：'A'）子機状態データ
*	・データ長＝12バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Request[1];			/* 要求内容		（'0'～'F'）												*/
									/*		 '0'：親機に対する要求無し											*/
									/*		 '1'：初期設定データ要求											*/
									/*		 '2'：センサー未確定											2005.08.26 早瀬・追加 */
									/*	'2'～'F'：予備															*/
	uchar	c_Type[1];				/* 装置種別							'0'固定（ロック装置）					*/
t_IF_LockSensor	unSensor[IFS_ROOM_MAX];	/* ロック装置センサー状態（バイナリ）									*/
									/*		bit0：ロック開センサー状態	0=OFF/1=ON								*/
									/*		bit1：ロック閉センサー状態	0=OFF/1=ON								*/
									/*		bit2：車両検知センサー状態	0=OFF/1=ON								*/
									/*		bit3：ロック装置動作状態	0=動作完結/1=動作中	(書き込み不可)	2005.03.04 早瀬・変更 */
									/*		bit4：ロック装置動作方向	0=閉動作方向/1=開動作方向				*/
									/*		bit5：予備					0=固定									*/
									/*		bit6：予備					0=固定									*/
									/*		bit7：メンテナンスモード	0=固定									*/
//CRC
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット							*/
									/*	[1]：CRC16ビットの上位8ビット							*/
} t_IF_Body_A41;

/****************************************
*	子機⇒親機
*	（56H：'V'）子機バージョンデータ
*	・データ長＝12バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Request[1];			/* 要求内容		（'0'～'F'）												*/
									/*		 '0'：親機に対する要求無し											*/
									/*		 '1'：初期設定データ要求											*/
									/*	'2'～'F'：予備															*/
	uchar	c_Reserved[1];			/* 予備								'0'固定									*/
	uchar	c_Version[8];			/* バージョン（部番、ASCII）												*/
//CRC
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット							*/
									/*	[1]：CRC16ビットの上位8ビット							*/
} t_IF_Body_V56;


/****************************************
*	フラップ子機⇒親機
*	（57H：'W'）フラップ子機状態書き込みデータ
*	・データ長＝9バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Reserved1[2];			// 予約 "00"固定
	uchar	c_Reserved2[2];			// 予約 "00"固定
	uchar	c_Reserved3[1];			// 予約 '0'固定
	uchar	c_Reserved4[1];			// 予約 '0'固定
	uchar	c_Command[1];			// 書き込みデータ	'1':ループ強制OFF
									//					'2':ループ強制ON
									//					'4':フラップ上昇
									//					'5':フラップ下降
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット	*/
									/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_W57;

/****************************************
*	フラップ子機⇒親機
*	（41H：'A'）フラップ子機状態データ
*	・データ長＝12バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Request[1];			// 要求内容 '0':親機に対する応答無し
	uchar	c_Type[1];				// 装置種別 'F'固定（フラップ装置）
	t_IF_FlapSensor t_FlapSensor;	// フラップセンサ状態情報
	uchar	c_Reserved2[4];			// 予約 "0000"固定
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット	*/
									/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_A41;

/****************************************
*	フラップ子機⇒親機
*	（41H：'A'）フラップ子機状態データ
*	・データ長＝12バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Request[1];			// 要求内容 '0':親機に対する応答無し
	t_IF_FlatLoopCounter t_LoopCounter;	// ループデータ
	uchar	ucCRC16[2];				/*	[0]：CRC16ビットの下位8ビット	*/
									/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_S53;
/****************************************
*	親機→子機
*	（49H：'I'）CRR初期設定データ
*	・データ長＝32バイト
*****************************************/
typedef struct {
	uchar	ucConnect[IFS_CRRFLAP_MAX][2];	/* CRR板No.毎、接続指定													*/
											/* 接点1～10毎にターミナルNo.を割り付ける								*/
											/* ucConnect[3] = '05'と設定すると、接点4はターミナルNo.5 となる		*/
//CRC
	uchar	ucCRC16[2];					/*	[0]：CRC16ビットの下位8ビット	*/
										/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_I49;
/****************************************
*	親機→子機
*	（56H：'V'）CRRバージョンデータ
*	・データ長＝10バイト
*****************************************/
typedef struct {
	uchar	dummy[8];					/* 予備								*/
//CRC
	uchar	ucCRC16[2];					/*	[0]：CRC16ビットの下位8ビット	*/
										/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_V56;
/****************************************
*	子機⇒親機
*	（76H：'v'）CRRバージョンデータ
*	・データ長＝10バイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_Version[8];				/* バージョン（部番、ASCII）		*/
//CRC
	uchar	ucCRC16[2];					/*	[0]：CRC16ビットの下位8ビット	*/
										/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_v76;
/****************************************
*	親機→子機
*	（54H：'T'）CRR折り返しテスト
*	・データ長＝10バイト
*****************************************/
typedef struct {
	uchar	dummy[8];					/* 予備								*/
//CRC
	uchar	ucCRC16[2];					/*	[0]：CRC16ビットの下位8ビット	*/
										/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_T54;
/****************************************
*	子機⇒親機
*	（74H：'t'）CRR折り返しテスト結果
*	・データ長＝17ﾊﾞｲﾄバイト（CRC含む）
*****************************************/
typedef struct {
	uchar	c_TestResult[IFS_CRRFLAP_MAX];	/* テスト結果						*/
//CRC
	uchar	ucCRC16[2];					/*	[0]：CRC16ビットの下位8ビット	*/
										/*	[1]：CRC16ビットの上位8ビット	*/
} t_FLAP_Body_t74;

/************************
*	親子間電文全体像	*
*************************/
typedef struct {
	t_IF_Header	sHead;				/* ヘッダ部分				  （共通）	データ長＝10 */
	union {
		t_IF_Body_I49	sI49;		/* 初期設定データ		（親機→子機）	データ長＝14 */
		t_IF_Body_R52	sR52;		/* 状態要求データ		（親機→子機）	データ長＝ 3 */
		t_IF_Body_W57	sW57;		/* 状態書込みデータ		（親機→子機）	データ長＝ 9 */
		t_IF_Body_ACK	sACK;		/* 肯定応答データ		（子機⇒親機）	データ長＝ 3 */
		t_IF_Body_NAK	sNAK;		/* 否定応答データ		（子機⇒親機）	データ長＝ 3 */
		t_IF_Body_A41	sA41;		/* 子機状態データ		（子機⇒親機）	データ長＝12 */
		t_IF_Body_V56	sV56;		/* 子機バージョンデータ	（子機⇒親機）	データ長＝12 */
		t_FLAP_Body_W57	sFlapW57;	/* 状態書込みデータ		（親機→子機）	データ長＝ 9 */
		t_FLAP_Body_A41	sFlapA41;	/* 子機状態データ		（子機⇒親機）	データ長＝12 */
		t_FLAP_Body_S53	sFlapS53;	/* ループデータ応答		（子機⇒親機）	データ長＝23 */
		t_FLAP_Body_I49	sFlapI49;	/* CRR初期設定データ	（親機→子機）	データ長＝32 */
		t_FLAP_Body_V56	sFlapV56;	/* CRRバージョンデータ	（親機→子機）	データ長＝10 */
		t_FLAP_Body_v76	sFlapv76;	/* CRRバージョンデータ	（子機⇒親機）	データ長＝10 */
		t_FLAP_Body_T54	sFlapT54;	/* CRR折り返しテスト	（親機→子機）	データ長＝10 */
		t_FLAP_Body_t74 sFlapt74;	/* CRR折り返しテスト結果（子機⇒親機）	データ長＝17 */
		uchar			Byte[1];	/* バイト列・・・必要？					電文最長＝24 */
	} unBody;
} t_IF_Packet;

#pragma unpack
/*
*	構造体メンバの境界調整数を「1」とする。を解除。
*/
#endif	// IF_H

